'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2018 Shape Security, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

/* eslint-disable no-use-before-define */

var _unicodeMatchPropertyValueEcmascript = require('unicode-match-property-value-ecmascript');

var _unicodeMatchPropertyValueEcmascript2 = _interopRequireDefault(_unicodeMatchPropertyValueEcmascript);

var _mappings = require('unicode-match-property-value-ecmascript/data/mappings');

var _mappings2 = _interopRequireDefault(_mappings);

var _unicodeMatchPropertyEcmascript = require('unicode-match-property-ecmascript');

var _unicodeMatchPropertyEcmascript2 = _interopRequireDefault(_unicodeMatchPropertyEcmascript);

var _unicodePropertyAliasesEcmascript = require('unicode-property-aliases-ecmascript');

var _unicodePropertyAliasesEcmascript2 = _interopRequireDefault(_unicodePropertyAliasesEcmascript);

var _unicode = require('./unicode');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var catchIsFalse = function catchIsFalse(predicate) {
  try {
    return !!predicate();
  } catch (e) {
    return false;
  }
};

var syntaxCharacters = '^$\\.*+?()[]{}|'.split('');
var extendedSyntaxCharacters = '^$\\.*+?()[|'.split('');

var controlEscapeCharacters = 'fnrtv'.split('');
var controlEscapeCharacterValues = { 'f': '\f'.charCodeAt(0), 'n': '\n'.charCodeAt(0), 'r': '\r'.charCodeAt(0), 't': '\t'.charCodeAt(0), 'v': '\v'.charCodeAt(0) };

var controlCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
var hexDigits = '0123456789abcdefABCDEF'.split('');
var decimalDigits = '0123456789'.split('');
var octalDigits = '01234567'.split('');

var INVALID_NAMED_BACKREFERENCE_SENTINEL = {};

function isIdentifierStart(ch) {
  return ch < 128 ? _unicode.idStartBool[ch] : _unicode.idStartLargeRegex.test(String.fromCodePoint(ch));
}

function isIdentifierPart(ch) {
  return ch < 128 ? _unicode.idContinueBool[ch] : _unicode.idContinueLargeRegex.test(String.fromCodePoint(ch));
}

var PatternAcceptorState = function () {
  function PatternAcceptorState(pattern, unicode) {
    _classCallCheck(this, PatternAcceptorState);

    this.pattern = pattern;
    this.unicode = unicode;
    this.index = 0;
    this.largestBackreference = 0;
    this.backreferenceNames = [];
    this.groupingNames = [];
    this.capturingGroups = 0;
  }

  _createClass(PatternAcceptorState, [{
    key: 'empty',
    value: function empty() {
      return this.index >= this.pattern.length;
    }
  }, {
    key: 'backreference',
    value: function backreference(ref) {
      if (ref > this.largestBackreference) {
        this.largestBackreference = ref;
      }
    }
  }, {
    key: 'nextCodePoint',
    value: function nextCodePoint() {
      if (this.empty()) {
        return null;
      }
      if (this.unicode) {
        return String.fromCodePoint(this.pattern.codePointAt(this.index));
      }
      return this.pattern.charAt(this.index);
    }
  }, {
    key: 'skipCodePoint',
    value: function skipCodePoint() {
      this.index += this.nextCodePoint().length;
    }
  }, {
    key: 'eat',
    value: function eat(str) {
      if (this.index + str.length > this.pattern.length || this.pattern.slice(this.index, this.index + str.length) !== str) {
        return false;
      }
      this.index += str.length;
      return true;
    }
  }, {
    key: 'eatIdentifierCodePoint',
    value: function eatIdentifierCodePoint() {
      var characterValue = void 0;
      var originalIndex = this.index;
      var character = void 0;
      if (this.match('\\u')) {
        this.skipCodePoint();
        characterValue = acceptUnicodeEscape(this);
        if (!characterValue.matched) {
          this.index = originalIndex;
          return null;
        }
        characterValue = characterValue.value;
        character = String.fromCodePoint(characterValue);
      } else {
        character = this.nextCodePoint();
        if (character == null) {
          this.index = originalIndex;
          return null;
        }
        this.index += character.length;
        characterValue = character.codePointAt(0);
      }
      return { character: character, characterValue: characterValue };
    }
  }, {
    key: 'eatIdentifierStart',
    value: function eatIdentifierStart() {
      var originalIndex = this.index;
      var codePoint = this.eatIdentifierCodePoint();
      if (codePoint === null) {
        this.index = originalIndex;
        return null;
      }
      if (codePoint.character === '_' || codePoint.character === '$' || isIdentifierStart(codePoint.characterValue)) {
        return codePoint.character;
      }
      this.index = originalIndex;
      return null;
    }
  }, {
    key: 'eatIdentifierPart',
    value: function eatIdentifierPart() {
      var originalIndex = this.index;
      var codePoint = this.eatIdentifierCodePoint();
      if (codePoint === null) {
        this.index = originalIndex;
        return null;
      }
      // ZWNJ / ZWJ
      if (codePoint.character === '\u200C' || codePoint.character === '\u200D' || codePoint.character === '$' || isIdentifierPart(codePoint.characterValue)) {
        return codePoint.character;
      }
      this.index = originalIndex;
      return null;
    }
  }, {
    key: 'eatAny',
    value: function eatAny() {
      for (var _len = arguments.length, strs = Array(_len), _key = 0; _key < _len; _key++) {
        strs[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = strs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var str = _step.value;

          if (this.eat(str)) {
            return str;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }, {
    key: 'match',
    value: function match(str) {
      return this.index + str.length <= this.pattern.length && this.pattern.slice(this.index, this.index + str.length) === str;
    }
  }, {
    key: 'matchAny',
    value: function matchAny() {
      for (var _len2 = arguments.length, strs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        strs[_key2] = arguments[_key2];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = strs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var str = _step2.value;

          if (this.match(str)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    }
  }, {
    key: 'eatNaturalNumber',
    value: function eatNaturalNumber() {
      var _this = this;

      var characters = [];
      var eatNumber = function eatNumber() {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = decimalDigits[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var str = _step3.value;

            if (_this.eat(str)) {
              characters.push(str);
              return true;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return false;
      };
      while (eatNumber()) {}
      return characters.length === 0 ? null : characters.join('');
    }
  }]);

  return PatternAcceptorState;
}();

// acceptRegex


exports.default = function (pattern) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$unicode = _ref.unicode,
      unicode = _ref$unicode === undefined ? false : _ref$unicode;

  var state = new PatternAcceptorState(pattern, unicode);
  var accepted = acceptDisjunction(state);
  if (accepted.matched) {
    if (state.unicode) {
      if (state.largestBackreference > state.capturingGroups) {
        return false;
      }
    }
    if (state.groupingNames.length > 0 || state.unicode) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = state.backreferenceNames[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var backreferenceName = _step4.value;

          if (state.groupingNames.indexOf(backreferenceName) === -1) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }
  return accepted.matched;
};

var backtrackOnFailure = function backtrackOnFailure(func) {
  return function (state) {
    var savedIndex = state.index;
    var oldBackreference = state.largestBackreference;
    var oldCapturingGroups = state.capturingGroups;
    var val = func(state);
    if (!val.matched) {
      state.index = savedIndex;
      state.largestBackreference = oldBackreference;
      state.capturingGroups = oldCapturingGroups;
    }
    return val;
  };
};

var acceptUnicodeEscape = backtrackOnFailure(function (state) {
  if (!state.eat('u')) {
    return { matched: false };
  }
  if (state.unicode && state.eat('{')) {
    var _digits = [];
    while (!state.eat('}')) {
      var digit = state.eatAny.apply(state, _toConsumableArray(hexDigits));
      if (digit === null) {
        return { matched: false };
      }
      _digits.push(digit);
    }
    var _value = parseInt(_digits.join(''), 16);
    return _value > 0x10FFFF ? { matched: false } : { matched: true, value: _value };
  }
  var digits = [0, 0, 0, 0].map(function () {
    return state.eatAny.apply(state, _toConsumableArray(hexDigits));
  });
  if (digits.some(function (digit) {
    return digit === null;
  })) {
    return { matched: false };
  }
  var value = parseInt(digits.join(''), 16);
  if (state.unicode && value >= 0xD800 && value <= 0xDBFF) {
    var surrogatePairValue = backtrackOnFailure(function (subState) {
      if (!subState.eat('\\u')) {
        return { matched: false };
      }
      var digits2 = [0, 0, 0, 0].map(function () {
        return subState.eatAny.apply(subState, _toConsumableArray(hexDigits));
      });
      if (digits2.some(function (digit) {
        return digit === null;
      })) {
        return { matched: false };
      }
      var value2 = parseInt(digits2.join(''), 16);
      if (value2 < 0xDC00 || value2 >= 0xE000) {
        return { matched: false };
      }
      return { matched: true, value: 0x10000 + ((value & 0x03FF) << 10) + (value2 & 0x03FF) };
    })(state);
    if (surrogatePairValue.matched) {
      return surrogatePairValue;
    }
  }
  return { matched: true, value: value };
});

var acceptDisjunction = function acceptDisjunction(state, terminator) {
  do {
    if (terminator !== void 0 && state.eat(terminator)) {
      return { matched: true };
    } else if (state.match('|')) {
      continue;
    }
    if (!acceptAlternative(state, terminator).matched) {
      return { matched: false };
    }
  } while (state.eat('|'));
  return { matched: terminator === void 0 || !!state.eat(terminator) };
};

var acceptAlternative = function acceptAlternative(state, terminator) {
  while (!state.match('|') && !state.empty() && (terminator === void 0 || !state.match(terminator))) {
    if (!acceptTerm(state).matched) {
      return { matched: false };
    }
  }
  return { matched: true };
};

var anyOf = function anyOf() {
  for (var _len3 = arguments.length, acceptors = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    acceptors[_key3] = arguments[_key3];
  }

  return function (state) {
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = acceptors[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var predicate = _step5.value;

        var value = predicate(state);
        if (value.matched) {
          return value;
        }
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    return { matched: false };
  };
};

var acceptTerm = function acceptTerm(state) {
  // non-quantified references are rolled into quantified accepts to improve performance significantly.
  if (state.unicode) {
    return anyOf(acceptAssertion, acceptQuantified(acceptAtom))(state);
  }
  return anyOf(acceptQuantified(acceptQuantifiableAssertion), acceptAssertion, acceptQuantified(acceptAtom))(state);
};

var acceptLabeledGroup = function acceptLabeledGroup(predicate) {
  return backtrackOnFailure(function (state) {
    if (!state.eat('(')) {
      return { matched: false };
    }
    if (predicate(state)) {
      return acceptDisjunction(state, ')');
    }
    return { matched: false };
  });
};

var acceptQuantifiableAssertion = acceptLabeledGroup(function (state) {
  return !!state.eatAny('?=', '?!');
});

var acceptAssertion = function acceptAssertion(state) {
  if (state.eatAny('^', '$', '\\b', '\\B')) {
    return { matched: true };
  }
  return acceptLabeledGroup(function (subState) {
    return subState.unicode ? !!subState.eatAny('?=', '?!', '?<=', '?<!') : !!subState.eatAny('?<=', '?<!');
  })(state);
};

var acceptDecimal = function acceptDecimal(state) {
  return { matched: state.eatNaturalNumber() !== null };
};

var acceptQuantified = function acceptQuantified(acceptor) {
  return backtrackOnFailure(function (state) {
    if (!acceptor(state).matched) {
      return { matched: false };
    }
    if (state.match('{')) {
      var value = backtrackOnFailure(function (subState) {
        subState.eat('{');
        var num1 = subState.eatNaturalNumber();
        if (num1 === null) {
          return { matched: false };
        }
        if (subState.eat(',') && subState.matchAny.apply(subState, _toConsumableArray(decimalDigits))) {
          var num2 = subState.eatNaturalNumber();
          if (num2 === null || parseInt(num1) > parseInt(num2)) {
            return { matched: false };
          }
        }
        if (!subState.eat('}')) {
          return { matched: false };
        }
        subState.eat('?');
        return { matched: true };
      })(state);
      if (!value.matched) {
        return { matched: !state.unicode };
      }
      return value;
    } else if (state.eatAny('*', '+', '?')) {
      state.eat('?');
    }
    return { matched: true };
  });
};

var acceptCharacterExcept = function acceptCharacterExcept(characters) {
  return function (state) {
    var nextCodePoint = state.nextCodePoint();
    if (nextCodePoint === null || characters.indexOf(nextCodePoint) !== -1) {
      return { matched: false };
    }
    state.skipCodePoint();
    return { matched: true };
  };
};

var acceptPatternCharacter = acceptCharacterExcept(syntaxCharacters);

var acceptExtendedPatternCharacter = acceptCharacterExcept(extendedSyntaxCharacters);

var acceptInvalidBracedQuantifier = function acceptInvalidBracedQuantifier(state) {
  return backtrackOnFailure(function (subState) {
    return { matched: !!(subState.eat('{') && acceptDecimal(subState).matched && (!subState.eat(',') || subState.match('}') || acceptDecimal(subState).matched) && subState.eat('}')) };
  })(state);
};

var acceptAtom = function acceptAtom(state) {
  if (state.unicode) {
    return anyOf(acceptPatternCharacter, function (subState) {
      return { matched: !!subState.eat('.') };
    }, backtrackOnFailure(function (subState) {
      return subState.eat('\\') ? acceptAtomEscape(subState) : { matched: false };
    }), acceptCharacterClass, acceptLabeledGroup(function (subState) {
      return subState.eat('?:');
    }), acceptGrouping)(state);
  }
  var matched = anyOf(function (subState) {
    return { matched: !!subState.eat('.') };
  }, backtrackOnFailure(function (subState) {
    return subState.eat('\\') ? acceptAtomEscape(subState) : { matched: false };
  }), backtrackOnFailure(function (subState) {
    return { matched: subState.eat('\\') && subState.match('c') };
  }), acceptCharacterClass, acceptLabeledGroup(function (subState) {
    return subState.eat('?:');
  }), acceptGrouping)(state);
  if (!matched.matched && acceptInvalidBracedQuantifier(state).matched) {
    return { matched: false };
  }
  return matched.matched ? matched : acceptExtendedPatternCharacter(state);
};

var acceptGrouping = backtrackOnFailure(function (state) {
  if (!state.eat('(')) {
    return { matched: false };
  }
  var groupName = backtrackOnFailure(function (subState) {
    if (!state.eat('?')) {
      return { matched: false };
    }
    return acceptGroupName(subState);
  })(state);
  if (!acceptDisjunction(state, ')').matched) {
    return { matched: false };
  }
  if (groupName.matched) {
    if (state.groupingNames.indexOf(groupName.data) !== -1) {
      return { matched: false };
    }
    state.groupingNames.push(groupName.data);
  }
  state.capturingGroups++;
  return { matched: true };
});

var acceptDecimalEscape = backtrackOnFailure(function (state) {
  var firstDecimal = state.eatAny.apply(state, _toConsumableArray(decimalDigits));
  if (firstDecimal === null) {
    return { matched: false };
  }
  if (firstDecimal === '0') {
    return { matched: true };
  }
  // we also accept octal escapes here, but it is impossible to tell if it is a octal escape until all parsing is complete.
  // octal escapes are handled in acceptCharacterEscape for classes
  state.backreference(parseInt(firstDecimal + (state.eatNaturalNumber() || '')));
  return { matched: true };
});

var acceptCharacterClassEscape = function acceptCharacterClassEscape(state) {
  if (state.eatAny('d', 'D', 's', 'S', 'w', 'W')) {
    return { matched: true };
  }
  if (state.unicode) {
    return backtrackOnFailure(function (subState) {
      if (!subState.eat('p{') && !subState.eat('P{')) {
        return { matched: false };
      }
      if (!acceptUnicodePropertyValueExpression(subState).matched) {
        return { matched: false };
      }
      return { matched: !!subState.eat('}') };
    })(state);
  }
  return { matched: false };
};

var acceptUnicodePropertyName = function acceptUnicodePropertyName(state) {
  var characters = [];
  var character = void 0;
  while (character = state.eatAny.apply(state, _toConsumableArray(controlCharacters).concat(['_']))) {
    // eslint-disable-line no-cond-assign
    characters.push(character);
  }
  return { matched: characters.length > 0, data: characters.join('') };
};

var acceptUnicodePropertyValue = function acceptUnicodePropertyValue(state) {
  var characters = [];
  var character = void 0;
  while (character = state.eatAny.apply(state, _toConsumableArray(controlCharacters).concat(_toConsumableArray(decimalDigits), ['_']))) {
    // eslint-disable-line no-cond-assign
    characters.push(character);
  }
  return { matched: characters.length > 0, data: characters.join('') };
};

// excluding nonbinary properties from mathias' list
// https://www.ecma-international.org/ecma-262/9.0/index.html#table-nonbinary-unicode-properties
var illegalLoneUnicodePropertyNames = ['General_Category', 'Script', 'Script_Extensions', 'scx', 'sc', 'gc'];

var generalCategoryValues = _mappings2.default.get('General_Category');

var acceptLoneUnicodePropertyNameOrValue = function acceptLoneUnicodePropertyNameOrValue(state) {
  var loneValue = acceptUnicodePropertyValue(state);
  if (!loneValue.matched || illegalLoneUnicodePropertyNames.includes(loneValue.data)) {
    return { matched: false };
  }

  return { matched: catchIsFalse(function () {
      return (0, _unicodeMatchPropertyEcmascript2.default)(loneValue.data);
    }) || generalCategoryValues.get(loneValue.data) != null };
};

var acceptUnicodePropertyValueExpression = function acceptUnicodePropertyValueExpression(state) {
  return anyOf(backtrackOnFailure(function (subState) {
    var name = acceptUnicodePropertyName(subState);
    if (!name.matched || !subState.eat('=')) {
      return { matched: false };
    }
    var value = acceptUnicodePropertyValue(subState);
    if (!value.matched) {
      return { matched: false };
    }
    return { matched: catchIsFalse(function () {
        return (0, _unicodeMatchPropertyValueEcmascript2.default)(_unicodePropertyAliasesEcmascript2.default.get(name.data) || name.data, value.data);
      }) };
  }), backtrackOnFailure(acceptLoneUnicodePropertyNameOrValue))(state);
};

var acceptCharacterEscape = anyOf(function (state) {
  var eaten = state.eatAny.apply(state, _toConsumableArray(controlEscapeCharacters));
  if (eaten === null) {
    return { matched: false };
  }
  return { matched: true, value: controlEscapeCharacterValues[eaten] };
}, backtrackOnFailure(function (state) {
  if (!state.eat('c')) {
    return { matched: false };
  }
  var character = state.eatAny.apply(state, _toConsumableArray(controlCharacters));
  if (character === null) {
    return { matched: false };
  }
  return { matched: true, value: character.charCodeAt(0) % 32 };
}), backtrackOnFailure(function (state) {
  if (!state.eat('0') || state.eatAny.apply(state, _toConsumableArray(decimalDigits))) {
    return { matched: false };
  }
  return { matched: true, value: 0 };
}), backtrackOnFailure(function (state) {
  if (!state.eat('x')) {
    return { matched: false };
  }
  var digits = [0, 0].map(function () {
    return state.eatAny.apply(state, _toConsumableArray(hexDigits));
  });
  if (digits.some(function (value) {
    return value === null;
  })) {
    return { matched: false };
  }
  return { matched: true, value: parseInt(digits.join(''), 16) };
}), acceptUnicodeEscape, backtrackOnFailure(function (state) {
  if (state.unicode) {
    return { matched: false };
  }
  var octal1 = state.eatAny.apply(state, _toConsumableArray(octalDigits));
  if (octal1 === null) {
    return { matched: false };
  }
  var octal1Value = parseInt(octal1, 8);
  if (octalDigits.indexOf(state.nextCodePoint()) === -1) {
    return { matched: true, value: octal1Value };
  }
  var octal2 = state.eatAny.apply(state, _toConsumableArray(octalDigits));
  var octal2Value = parseInt(octal2, 8);
  if (octal1Value < 4) {
    if (octalDigits.indexOf(state.nextCodePoint()) === -1) {
      return { matched: true, value: octal1Value << 3 | octal2Value };
    }
    var octal3 = state.eatAny.apply(state, _toConsumableArray(octalDigits));
    var octal3Value = parseInt(octal3, 8);
    return { matched: true, value: octal1Value << 6 | octal2Value << 3 | octal3Value };
  }
  return { matched: true, value: octal1Value << 3 | octal2Value };
}), backtrackOnFailure(function (state) {
  if (!state.unicode) {
    return { matched: false };
  }
  var value = state.eatAny.apply(state, _toConsumableArray(syntaxCharacters));
  if (value === null) {
    return { matched: false };
  }
  return { matched: true, value: value.charCodeAt(0) };
}), function (state) {
  if (!state.unicode || !state.eat('/')) {
    return { matched: false };
  }
  return { matched: true, value: '/'.charCodeAt(0) };
}, backtrackOnFailure(function (state) {
  if (state.unicode) {
    return { matched: false };
  }
  var next = state.nextCodePoint();
  if (next !== null && next !== 'c' && next !== 'k') {
    state.skipCodePoint();
    return { matched: true, value: next.codePointAt(0) };
  }
  return { matched: false };
}));

var acceptGroupNameBackreference = backtrackOnFailure(function (state) {
  if (!state.eat('k')) {
    return { matched: false };
  }
  var name = acceptGroupName(state);
  if (!name.matched) {
    state.backreferenceNames.push(INVALID_NAMED_BACKREFERENCE_SENTINEL);
    return { matched: true };
  }
  state.backreferenceNames.push(name.data);
  return { matched: true };
});

var acceptGroupName = backtrackOnFailure(function (state) {
  if (!state.eat('<')) {
    return { matched: false };
  }
  var characters = [];
  var start = state.eatIdentifierStart();
  if (!start) {
    return { matched: false };
  }
  characters.push(start);
  var part = void 0;
  while (part = state.eatIdentifierPart()) {
    // eslint-disable-line no-cond-assign
    characters.push(part);
  }
  if (!state.eat('>')) {
    return { matched: false };
  }
  return { matched: characters.length > 0, data: characters.join('') };
});

var acceptAtomEscape = anyOf(acceptDecimalEscape, acceptCharacterClassEscape, acceptCharacterEscape, acceptGroupNameBackreference);

var acceptCharacterClass = backtrackOnFailure(function (state) {
  if (!state.eat('[')) {
    return { matched: false };
  }
  state.eat('^');

  var acceptClassEscape = anyOf(function (subState) {
    return { matched: !!subState.eat('b'), value: 0x0008 };
  }, function (subState) {
    return { matched: subState.unicode && !!subState.eat('-'), value: '-'.charCodeAt(0) };
  }, backtrackOnFailure(function (subState) {
    if (subState.unicode || !subState.eat('c')) {
      return { matched: false };
    }
    var character = subState.eatAny.apply(subState, _toConsumableArray(decimalDigits).concat(['_']));
    if (character === null) {
      return { matched: false };
    }
    return { matched: true, value: character.charCodeAt(0) % 32 };
  }), acceptCharacterClassEscape, acceptCharacterEscape,
  // We special-case `\k` because `acceptCharacterEscape` rejects `\k` unconditionally,
  // deferring `\k` to acceptGroupNameBackreference, which is not called here.
  // See also https://github.com/tc39/ecma262/issues/2037. This code takes the route of
  // making it unconditionally legal, rather than legal only in the absence of a group name.
  function (subState) {
    return { matched: !subState.unicode && !!subState.eat('k'), value: 107 };
  });

  var acceptClassAtomNoDash = function acceptClassAtomNoDash(localState) {
    var nextCodePoint = localState.nextCodePoint();
    if (nextCodePoint === ']' || nextCodePoint === '-' || nextCodePoint === null) {
      return { matched: false };
    }
    if (nextCodePoint !== '\\') {
      localState.skipCodePoint();
      return { matched: true, value: nextCodePoint.codePointAt(0) };
    }
    localState.eat('\\');
    var classEscape = acceptClassEscape(localState);
    if (!classEscape.matched && localState.nextCodePoint() === 'c' && !localState.unicode) {
      return { matched: true, value: '\\'.charCodeAt(0) };
    }
    return classEscape;
  };

  var acceptClassAtom = function acceptClassAtom(localState) {
    if (localState.eat('-')) {
      return { matched: true, value: '-'.charCodeAt(0) };
    }
    return acceptClassAtomNoDash(localState);
  };

  var finishClassRange = function finishClassRange(localState, atom) {
    var isUnvaluedPassedAtom = function isUnvaluedPassedAtom(subAtom) {
      return subAtom.value === void 0 && subAtom.matched;
    };
    if (localState.eat('-')) {
      if (localState.match(']')) {
        return { matched: true };
      }
      var otherAtom = acceptClassAtom(localState);
      if (!otherAtom.matched) {
        return { matched: false };
      }
      if (localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) {
        return { matched: false };
      } else if (!(!localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) && atom.value > otherAtom.value) {
        return { matched: false };
      } else if (localState.match(']')) {
        return { matched: true };
      }
      return acceptNonEmptyClassRanges(localState);
    }
    if (localState.match(']')) {
      return { matched: true };
    }
    return acceptNonEmptyClassRangesNoDash(localState);
  };

  var acceptNonEmptyClassRanges = function acceptNonEmptyClassRanges(localState) {
    var atom = acceptClassAtom(localState);
    return atom.matched ? finishClassRange(localState, atom) : { matched: false };
  };

  var acceptNonEmptyClassRangesNoDash = function acceptNonEmptyClassRangesNoDash(localState) {
    var atom = acceptClassAtomNoDash(localState);
    return atom.matched ? finishClassRange(localState, atom) : { matched: false };
  };

  if (state.eat(']')) {
    return { matched: true };
  }

  var value = acceptNonEmptyClassRanges(state);
  if (value.matched) {
    state.eat(']'); // cannot fail, as above will not return matched if it is not seen in advance
  }

  return value;
});