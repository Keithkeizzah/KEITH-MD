{"version":3,"file":"index.mjs","sources":["../src/util.ts","../src/hash.ts"],"sourcesContent":["export function sortNumbers(a: string, b: string) {\n  return a > b ? 1 : -1;\n}\n","import { sortNumbers } from './util';\n\n/**\n * Hashes a given value into a unique number.\n *\n * This function accepts **ANY** kind of value, like `functions`, `classes`, `objects` and\n * so on.\n *\n * **Note**: Symbols uniqueness are not guaranteed, as they are transformed to strings.\n *\n * @example\n *\n * ```ts\n * class B {}\n *\n * const bHash = hash(B);\n * const bInstanceHash = hash(new B());\n * const bArrayHash = hash([B, new B(), new B(), { b: new B() }]);\n * const bBuilderHash = hash(() => B);\n * const bFactoryHash = hash(() => new B());\n * ```\n *\n * @param val The value to be hashed\n * @returns The signed integer result from the provided value\n * @see https://tinylibs.js.org/packages/object-code/\n */\nexport function hash(val: unknown, seen?: WeakSet<object>): number {\n  let h = 5381;\n\n  // Objects should be recursively hashed\n  if (\n    typeof val === 'object' &&\n    val !== null &&\n    (val.toString === Object.prototype.toString ||\n      val.toString === Array.prototype.toString)\n  ) {\n    if (!seen) {\n      seen = new WeakSet();\n    }\n\n    // Sort keys to keep the hash consistent\n    const keys = Object.keys(val).sort(sortNumbers);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = val[key as keyof typeof val] as object;\n\n      h = (h * 33) ^ hash(key, seen);\n\n      // Uses an internal WeakMap to keep track of previous seen values\n      // and avoid circular references serializations which would cause\n      // an infinite loop.\n      if (\n        typeof value === 'object' &&\n        value !== null &&\n        (val.toString === Object.prototype.toString ||\n          val.toString === Array.prototype.toString)\n      ) {\n        if (seen.has(value)) {\n          continue;\n        }\n\n        seen.add(value);\n      }\n\n      // Hashes the value\n      h = (h * 33) ^ hash(value, seen);\n    }\n\n    // Also hashes the constructor\n    h = (h * 33) ^ hash(val.constructor, seen);\n\n    return h;\n  }\n\n  let toHash = typeof val;\n\n  try {\n    if (val instanceof Date) {\n      toHash += val.getTime();\n    } else {\n      toHash += String(val);\n    }\n  } catch (error) {\n    toHash += String(Object.assign({}, val));\n  }\n\n  for (let i = 0; i < toHash.length; i++) {\n    h = (h * 33) ^ toHash.charCodeAt(i);\n  }\n\n  return h;\n}\n"],"names":["sortNumbers","a","b","hash","val","seen","h","toString","Object","prototype","Array","WeakSet","keys","sort","i","length","key","value","has","add","constructor","toHash","Date","getTime","String","error","assign","charCodeAt"],"mappings":"SAAgBA,EAAYC,EAAWC,GACrC,OAAOD,EAAIC,EAAI,GAAK,CACtB,CCwBgB,SAAAC,EAAKC,EAAcC,GACjC,IAAIC,EAAI,KAGR,GACiB,iBAARF,GACC,OAARA,IACCA,EAAIG,WAAaC,OAAOC,UAAUF,UACjCH,EAAIG,WAAaG,MAAMD,UAAUF,UACnC,CACKF,IACHA,EAAO,IAAIM,SAMb,IAFA,IAAMC,EAAOJ,OAAOI,KAAKR,GAAKS,KAAKb,GAE1Bc,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAAK,CACpC,IAAME,EAAMJ,EAAKE,GACXG,EAAQb,EAAIY,GAOlB,GALAV,EAAS,GAAJA,EAAUH,EAAKa,EAAKX,GAMN,iBAAVY,GACG,OAAVA,IACCb,EAAIG,WAAaC,OAAOC,UAAUF,UACjCH,EAAIG,WAAaG,MAAMD,UAAUF,UACnC,CACA,GAAIF,EAAKa,IAAID,GACX,SAGFZ,EAAKc,IAAIF,EACX,CAGAX,EAAS,GAAJA,EAAUH,EAAKc,EAAOZ,EAC7B,CAKA,OAFS,GAAJC,EAAUH,EAAKC,EAAIgB,YAAaf,EAGvC,CAEA,IAAIgB,SAAgBjB,EAEpB,IACMA,aAAekB,KACjBD,GAAUjB,EAAImB,UAEdF,GAAUG,OAAOpB,EAErB,CAAE,MAAOqB,GACPJ,GAAUG,OAAOhB,OAAOkB,OAAO,GAAItB,GACrC,CAEA,IAAK,IAAIU,EAAI,EAAGA,EAAIO,EAAON,OAAQD,IACjCR,EAAS,GAAJA,EAAUe,EAAOM,WAAWb,GAGnC,OAAOR,CACT"}