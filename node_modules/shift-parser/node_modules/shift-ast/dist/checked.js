'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by src/generate-checked.js.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return typeof node === 'undefined' || node.type !== 'ArrayExpression' && node.type !== 'ArrowExpression' && node.type !== 'AssignmentExpression' && node.type !== 'AwaitExpression' && node.type !== 'BinaryExpression' && node.type !== 'CallExpression' && node.type !== 'ClassExpression' && node.type !== 'CompoundAssignmentExpression' && node.type !== 'ConditionalExpression' && node.type !== 'FunctionExpression' && node.type !== 'IdentifierExpression' && node.type !== 'LiteralBooleanExpression' && node.type !== 'LiteralInfinityExpression' && node.type !== 'LiteralNullExpression' && node.type !== 'LiteralNumericExpression' && node.type !== 'LiteralRegExpExpression' && node.type !== 'LiteralStringExpression' && node.type !== 'ComputedMemberExpression' && node.type !== 'StaticMemberExpression' && node.type !== 'NewExpression' && node.type !== 'NewTargetExpression' && node.type !== 'ObjectExpression' && node.type !== 'TemplateExpression' && node.type !== 'ThisExpression' && node.type !== 'UnaryExpression' && node.type !== 'UpdateExpression' && node.type !== 'YieldExpression' && node.type !== 'YieldGeneratorExpression';
}

function isNotStatement(node) {
  return typeof node === 'undefined' || node.type !== 'BlockStatement' && node.type !== 'BreakStatement' && node.type !== 'ClassDeclaration' && node.type !== 'ContinueStatement' && node.type !== 'DebuggerStatement' && node.type !== 'EmptyStatement' && node.type !== 'ExpressionStatement' && node.type !== 'FunctionDeclaration' && node.type !== 'IfStatement' && node.type !== 'DoWhileStatement' && node.type !== 'ForAwaitStatement' && node.type !== 'ForInStatement' && node.type !== 'ForOfStatement' && node.type !== 'ForStatement' && node.type !== 'WhileStatement' && node.type !== 'LabeledStatement' && node.type !== 'ReturnStatement' && node.type !== 'SwitchStatement' && node.type !== 'SwitchStatementWithDefault' && node.type !== 'ThrowStatement' && node.type !== 'TryCatchStatement' && node.type !== 'TryFinallyStatement' && node.type !== 'VariableDeclarationStatement' && node.type !== 'WithStatement';
}

function printActualType(arg) {
  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
    return typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
  }
  if (Array.isArray(arg)) {
    return '[' + arg.map(printActualType).join(', ') + ']';
  }
  if (arg === null) {
    return null;
  }
  if (!arg.type) {
    return JSON.stringify(arg);
  }
  return arg.type;
}

function arrayEquals(a, b) {
  return a.length === b.length && a.every(function (v, i) {
    return v === b[i];
  });
}

var ArrayAssignmentTarget = exports.ArrayAssignmentTarget = function ArrayAssignmentTarget(arg) {
  _classCallCheck(this, ArrayAssignmentTarget);

  var elements = arg.elements,
      rest = arg.rest;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ArrayAssignmentTarget constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {
    throw new TypeError('Argument to ArrayAssignmentTarget constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || f !== null && f.type !== 'AssignmentTargetWithDefault' && f.type !== 'ArrayAssignmentTarget' && f.type !== 'ObjectAssignmentTarget' && f.type !== 'AssignmentTargetIdentifier' && f.type !== 'ComputedMemberAssignmentTarget' && f.type !== 'StaticMemberAssignmentTarget';
  })) {
    throw new TypeError('Field "elements" of ArrayAssignmentTarget constructor argument is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got ' + printActualType(elements) + ')');
  }
  if (typeof rest === 'undefined' || rest !== null && rest.type !== 'ArrayAssignmentTarget' && rest.type !== 'ObjectAssignmentTarget' && rest.type !== 'AssignmentTargetIdentifier' && rest.type !== 'ComputedMemberAssignmentTarget' && rest.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "rest" of ArrayAssignmentTarget constructor argument is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ArrayAssignmentTarget';
  this.elements = elements;
  this.rest = rest;
};

var ArrayBinding = exports.ArrayBinding = function ArrayBinding(arg) {
  _classCallCheck(this, ArrayBinding);

  var elements = arg.elements,
      rest = arg.rest;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ArrayBinding constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {
    throw new TypeError('Argument to ArrayBinding constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || f !== null && f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding';
  })) {
    throw new TypeError('Field "elements" of ArrayBinding constructor argument is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(elements) + ')');
  }
  if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {
    throw new TypeError('Field "rest" of ArrayBinding constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ArrayBinding';
  this.elements = elements;
  this.rest = rest;
};

var ArrayExpression = exports.ArrayExpression = function ArrayExpression(arg) {
  _classCallCheck(this, ArrayExpression);

  var elements = arg.elements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ArrayExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements'])) {
    throw new TypeError('Argument to ArrayExpression constructor has wrong keys: expected {elements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || f !== null && isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "elements" of ArrayExpression constructor argument is of incorrect type (expected [null or one of {Expression, SpreadElement}], got ' + printActualType(elements) + ')');
  }
  this.type = 'ArrayExpression';
  this.elements = elements;
};

var ArrowExpression = exports.ArrowExpression = function ArrowExpression(arg) {
  _classCallCheck(this, ArrowExpression);

  var isAsync = arg.isAsync,
      params = arg.params,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ArrowExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'params'])) {
    throw new TypeError('Argument to ArrowExpression constructor has wrong keys: expected {isAsync, params, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isAsync !== 'boolean') {
    throw new TypeError('Field "isAsync" of ArrowExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');
  }
  if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of ArrowExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (typeof body === 'undefined' || isNotExpression(body) && body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of ArrowExpression constructor argument is of incorrect type (expected one of {Expression, FunctionBody}, got ' + printActualType(body) + ')');
  }
  this.type = 'ArrowExpression';
  this.isAsync = isAsync;
  this.params = params;
  this.body = body;
};

var AssignmentExpression = exports.AssignmentExpression = function AssignmentExpression(arg) {
  _classCallCheck(this, AssignmentExpression);

  var binding = arg.binding,
      expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AssignmentExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression'])) {
    throw new TypeError('Argument to AssignmentExpression constructor has wrong keys: expected {binding, expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentExpression constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of AssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'AssignmentExpression';
  this.binding = binding;
  this.expression = expression;
};

var AssignmentTargetIdentifier = exports.AssignmentTargetIdentifier = function AssignmentTargetIdentifier(arg) {
  _classCallCheck(this, AssignmentTargetIdentifier);

  var name = arg.name;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AssignmentTargetIdentifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {
    throw new TypeError('Argument to AssignmentTargetIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name !== 'string') {
    throw new TypeError('Field "name" of AssignmentTargetIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'AssignmentTargetIdentifier';
  this.name = name;
};

var AssignmentTargetPropertyIdentifier = exports.AssignmentTargetPropertyIdentifier = function AssignmentTargetPropertyIdentifier(arg) {
  _classCallCheck(this, AssignmentTargetPropertyIdentifier);

  var binding = arg.binding,
      init = arg.init;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AssignmentTargetPropertyIdentifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {
    throw new TypeError('Argument to AssignmentTargetPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier') {
    throw new TypeError('Field "binding" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected AssignmentTargetIdentifier, got ' + printActualType(binding) + ')');
  }
  if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'AssignmentTargetPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var AssignmentTargetPropertyProperty = exports.AssignmentTargetPropertyProperty = function AssignmentTargetPropertyProperty(arg) {
  _classCallCheck(this, AssignmentTargetPropertyProperty);

  var name = arg.name,
      binding = arg.binding;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AssignmentTargetPropertyProperty constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {
    throw new TypeError('Argument to AssignmentTargetPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetWithDefault' && binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  this.type = 'AssignmentTargetPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var AssignmentTargetWithDefault = exports.AssignmentTargetWithDefault = function AssignmentTargetWithDefault(arg) {
  _classCallCheck(this, AssignmentTargetWithDefault);

  var binding = arg.binding,
      init = arg.init;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AssignmentTargetWithDefault constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {
    throw new TypeError('Argument to AssignmentTargetWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(init)) {
    throw new TypeError('Field "init" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'AssignmentTargetWithDefault';
  this.binding = binding;
  this.init = init;
};

var AwaitExpression = exports.AwaitExpression = function AwaitExpression(arg) {
  _classCallCheck(this, AwaitExpression);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('AwaitExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to AwaitExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of AwaitExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'AwaitExpression';
  this.expression = expression;
};

var BinaryExpression = exports.BinaryExpression = function BinaryExpression(arg) {
  _classCallCheck(this, BinaryExpression);

  var left = arg.left,
      operator = arg.operator,
      right = arg.right;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BinaryExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['left', 'operator', 'right'])) {
    throw new TypeError('Argument to BinaryExpression constructor has wrong keys: expected {left, operator, right}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(left)) {
    throw new TypeError('Field "left" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(left) + ')');
  }
  if (typeof operator === 'undefined' || ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof', '<<', '>>', '>>>', '+', '-', '*', '/', '%', '**', ',', '||', '&&', '|', '^', '&'].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of BinaryExpression constructor argument is of incorrect type (expected one of {"==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  this.type = 'BinaryExpression';
  this.left = left;
  this.operator = operator;
  this.right = right;
};

var BindingIdentifier = exports.BindingIdentifier = function BindingIdentifier(arg) {
  _classCallCheck(this, BindingIdentifier);

  var name = arg.name;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BindingIdentifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {
    throw new TypeError('Argument to BindingIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name !== 'string') {
    throw new TypeError('Field "name" of BindingIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'BindingIdentifier';
  this.name = name;
};

var BindingPropertyIdentifier = exports.BindingPropertyIdentifier = function BindingPropertyIdentifier(arg) {
  _classCallCheck(this, BindingPropertyIdentifier);

  var binding = arg.binding,
      init = arg.init;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BindingPropertyIdentifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {
    throw new TypeError('Argument to BindingPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "binding" of BindingPropertyIdentifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
  }
  if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of BindingPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'BindingPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var BindingPropertyProperty = exports.BindingPropertyProperty = function BindingPropertyProperty(arg) {
  _classCallCheck(this, BindingPropertyProperty);

  var name = arg.name,
      binding = arg.binding;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BindingPropertyProperty constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {
    throw new TypeError('Argument to BindingPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingWithDefault' && binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  this.type = 'BindingPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var BindingWithDefault = exports.BindingWithDefault = function BindingWithDefault(arg) {
  _classCallCheck(this, BindingWithDefault);

  var binding = arg.binding,
      init = arg.init;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BindingWithDefault constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {
    throw new TypeError('Argument to BindingWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of BindingWithDefault constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(init)) {
    throw new TypeError('Field "init" of BindingWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'BindingWithDefault';
  this.binding = binding;
  this.init = init;
};

var Block = exports.Block = function Block(arg) {
  _classCallCheck(this, Block);

  var statements = arg.statements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Block constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['statements'])) {
    throw new TypeError('Argument to Block constructor has wrong keys: expected {statements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of Block constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'Block';
  this.statements = statements;
};

var BlockStatement = exports.BlockStatement = function BlockStatement(arg) {
  _classCallCheck(this, BlockStatement);

  var block = arg.block;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BlockStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['block'])) {
    throw new TypeError('Argument to BlockStatement constructor has wrong keys: expected {block}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof block === 'undefined' || block.type !== 'Block') {
    throw new TypeError('Field "block" of BlockStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(block) + ')');
  }
  this.type = 'BlockStatement';
  this.block = block;
};

var BreakStatement = exports.BreakStatement = function BreakStatement(arg) {
  _classCallCheck(this, BreakStatement);

  var label = arg.label;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('BreakStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {
    throw new TypeError('Argument to BreakStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof label === 'undefined' || label !== null && typeof label !== 'string') {
    throw new TypeError('Field "label" of BreakStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
  }
  this.type = 'BreakStatement';
  this.label = label;
};

var CallExpression = exports.CallExpression = function CallExpression(arg) {
  _classCallCheck(this, CallExpression);

  var callee = arg.callee,
      _arguments = arg.arguments;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('CallExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {
    throw new TypeError('Argument to CallExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof callee === 'undefined' || isNotExpression(callee) && callee.type !== 'Super') {
    throw new TypeError('Field "callee" of CallExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(callee) + ')');
  }
  if (!Array.isArray(_arguments) || _arguments.some(function (f) {
    return typeof f === 'undefined' || isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "arguments" of CallExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
  }
  this.type = 'CallExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var CatchClause = exports.CatchClause = function CatchClause(arg) {
  _classCallCheck(this, CatchClause);

  var binding = arg.binding,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('CatchClause constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'body'])) {
    throw new TypeError('Argument to CatchClause constructor has wrong keys: expected {binding, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of CatchClause constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'Block') {
    throw new TypeError('Field "body" of CatchClause constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  this.type = 'CatchClause';
  this.binding = binding;
  this.body = body;
};

var ClassDeclaration = exports.ClassDeclaration = function ClassDeclaration(arg) {
  _classCallCheck(this, ClassDeclaration);

  var name = arg.name,
      _super = arg.super,
      elements = arg.elements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ClassDeclaration constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {
    throw new TypeError('Argument to ClassDeclaration constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of ClassDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (typeof _super === 'undefined' || _super !== null && isNotExpression(_super)) {
    throw new TypeError('Field "super" of ClassDeclaration constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'ClassElement';
  })) {
    throw new TypeError('Field "elements" of ClassDeclaration constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
  }
  this.type = 'ClassDeclaration';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var ClassElement = exports.ClassElement = function ClassElement(arg) {
  _classCallCheck(this, ClassElement);

  var isStatic = arg.isStatic,
      method = arg.method;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ClassElement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['isStatic', 'method'])) {
    throw new TypeError('Argument to ClassElement constructor has wrong keys: expected {isStatic, method}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isStatic !== 'boolean') {
    throw new TypeError('Field "isStatic" of ClassElement constructor argument is of incorrect type (expected boolean, got ' + printActualType(isStatic) + ')');
  }
  if (typeof method === 'undefined' || method.type !== 'Getter' && method.type !== 'Method' && method.type !== 'Setter') {
    throw new TypeError('Field "method" of ClassElement constructor argument is of incorrect type (expected one of {Getter, Method, Setter}, got ' + printActualType(method) + ')');
  }
  this.type = 'ClassElement';
  this.isStatic = isStatic;
  this.method = method;
};

var ClassExpression = exports.ClassExpression = function ClassExpression(arg) {
  _classCallCheck(this, ClassExpression);

  var name = arg.name,
      _super = arg.super,
      elements = arg.elements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ClassExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {
    throw new TypeError('Argument to ClassExpression constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name !== null && name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of ClassExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (typeof _super === 'undefined' || _super !== null && isNotExpression(_super)) {
    throw new TypeError('Field "super" of ClassExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'ClassElement';
  })) {
    throw new TypeError('Field "elements" of ClassExpression constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
  }
  this.type = 'ClassExpression';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var CompoundAssignmentExpression = exports.CompoundAssignmentExpression = function CompoundAssignmentExpression(arg) {
  _classCallCheck(this, CompoundAssignmentExpression);

  var binding = arg.binding,
      operator = arg.operator,
      expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('CompoundAssignmentExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression', 'operator'])) {
    throw new TypeError('Argument to CompoundAssignmentExpression constructor has wrong keys: expected {binding, operator, expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (typeof operator === 'undefined' || ['+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '|=', '^=', '&='].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {"+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of CompoundAssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'CompoundAssignmentExpression';
  this.binding = binding;
  this.operator = operator;
  this.expression = expression;
};

var ComputedMemberAssignmentTarget = exports.ComputedMemberAssignmentTarget = function ComputedMemberAssignmentTarget(arg) {
  _classCallCheck(this, ComputedMemberAssignmentTarget);

  var object = arg.object,
      expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ComputedMemberAssignmentTarget constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {
    throw new TypeError('Argument to ComputedMemberAssignmentTarget constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedMemberAssignmentTarget';
  this.object = object;
  this.expression = expression;
};

var ComputedMemberExpression = exports.ComputedMemberExpression = function ComputedMemberExpression(arg) {
  _classCallCheck(this, ComputedMemberExpression);

  var object = arg.object,
      expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ComputedMemberExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {
    throw new TypeError('Argument to ComputedMemberExpression constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of ComputedMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedMemberExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedMemberExpression';
  this.object = object;
  this.expression = expression;
};

var ComputedPropertyName = exports.ComputedPropertyName = function ComputedPropertyName(arg) {
  _classCallCheck(this, ComputedPropertyName);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ComputedPropertyName constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to ComputedPropertyName constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedPropertyName constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedPropertyName';
  this.expression = expression;
};

var ConditionalExpression = exports.ConditionalExpression = function ConditionalExpression(arg) {
  _classCallCheck(this, ConditionalExpression);

  var test = arg.test,
      consequent = arg.consequent,
      alternate = arg.alternate;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ConditionalExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {
    throw new TypeError('Argument to ConditionalExpression constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotExpression(consequent)) {
    throw new TypeError('Field "consequent" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(consequent) + ')');
  }
  if (isNotExpression(alternate)) {
    throw new TypeError('Field "alternate" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(alternate) + ')');
  }
  this.type = 'ConditionalExpression';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var ContinueStatement = exports.ContinueStatement = function ContinueStatement(arg) {
  _classCallCheck(this, ContinueStatement);

  var label = arg.label;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ContinueStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {
    throw new TypeError('Argument to ContinueStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof label === 'undefined' || label !== null && typeof label !== 'string') {
    throw new TypeError('Field "label" of ContinueStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
  }
  this.type = 'ContinueStatement';
  this.label = label;
};

var DataProperty = exports.DataProperty = function DataProperty(arg) {
  _classCallCheck(this, DataProperty);

  var name = arg.name,
      expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('DataProperty constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'name'])) {
    throw new TypeError('Argument to DataProperty constructor has wrong keys: expected {name, expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of DataProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of DataProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'DataProperty';
  this.name = name;
  this.expression = expression;
};

var DebuggerStatement = exports.DebuggerStatement = function DebuggerStatement() {
  _classCallCheck(this, DebuggerStatement);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('DebuggerStatement constructor takes no arguments');
  }
  this.type = 'DebuggerStatement';
};

var Directive = exports.Directive = function Directive(arg) {
  _classCallCheck(this, Directive);

  var rawValue = arg.rawValue;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Directive constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {
    throw new TypeError('Argument to Directive constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof rawValue !== 'string') {
    throw new TypeError('Field "rawValue" of Directive constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
  }
  this.type = 'Directive';
  this.rawValue = rawValue;
};

var DoWhileStatement = exports.DoWhileStatement = function DoWhileStatement(arg) {
  _classCallCheck(this, DoWhileStatement);

  var body = arg.body,
      test = arg.test;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('DoWhileStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {
    throw new TypeError('Argument to DoWhileStatement constructor has wrong keys: expected {body, test}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of DoWhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of DoWhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  this.type = 'DoWhileStatement';
  this.body = body;
  this.test = test;
};

var EmptyStatement = exports.EmptyStatement = function EmptyStatement() {
  _classCallCheck(this, EmptyStatement);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('EmptyStatement constructor takes no arguments');
  }
  this.type = 'EmptyStatement';
};

var Export = exports.Export = function Export(arg) {
  _classCallCheck(this, Export);

  var declaration = arg.declaration;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Export constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {
    throw new TypeError('Argument to Export constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof declaration === 'undefined' || declaration.type !== 'ClassDeclaration' && declaration.type !== 'FunctionDeclaration' && declaration.type !== 'VariableDeclaration') {
    throw new TypeError('Field "declaration" of Export constructor argument is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got ' + printActualType(declaration) + ')');
  }
  this.type = 'Export';
  this.declaration = declaration;
};

var ExportAllFrom = exports.ExportAllFrom = function ExportAllFrom(arg) {
  _classCallCheck(this, ExportAllFrom);

  var moduleSpecifier = arg.moduleSpecifier;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportAllFrom constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier'])) {
    throw new TypeError('Argument to ExportAllFrom constructor has wrong keys: expected {moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ExportAllFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ExportAllFrom';
  this.moduleSpecifier = moduleSpecifier;
};

var ExportDefault = exports.ExportDefault = function ExportDefault(arg) {
  _classCallCheck(this, ExportDefault);

  var body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportDefault constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body'])) {
    throw new TypeError('Argument to ExportDefault constructor has wrong keys: expected {body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof body === 'undefined' || body.type !== 'ClassDeclaration' && isNotExpression(body) && body.type !== 'FunctionDeclaration') {
    throw new TypeError('Field "body" of ExportDefault constructor argument is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got ' + printActualType(body) + ')');
  }
  this.type = 'ExportDefault';
  this.body = body;
};

var ExportFrom = exports.ExportFrom = function ExportFrom(arg) {
  _classCallCheck(this, ExportFrom);

  var namedExports = arg.namedExports,
      moduleSpecifier = arg.moduleSpecifier;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportFrom constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier', 'namedExports'])) {
    throw new TypeError('Argument to ExportFrom constructor has wrong keys: expected {namedExports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(namedExports) || namedExports.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'ExportFromSpecifier';
  })) {
    throw new TypeError('Field "namedExports" of ExportFrom constructor argument is of incorrect type (expected [ExportFromSpecifier], got ' + printActualType(namedExports) + ')');
  }
  if (typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ExportFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ExportFrom';
  this.namedExports = namedExports;
  this.moduleSpecifier = moduleSpecifier;
};

var ExportFromSpecifier = exports.ExportFromSpecifier = function ExportFromSpecifier(arg) {
  _classCallCheck(this, ExportFromSpecifier);

  var name = arg.name,
      exportedName = arg.exportedName;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportFromSpecifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {
    throw new TypeError('Argument to ExportFromSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name !== 'string') {
    throw new TypeError('Field "name" of ExportFromSpecifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  if (typeof exportedName === 'undefined' || exportedName !== null && typeof exportedName !== 'string') {
    throw new TypeError('Field "exportedName" of ExportFromSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
  }
  this.type = 'ExportFromSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocalSpecifier = exports.ExportLocalSpecifier = function ExportLocalSpecifier(arg) {
  _classCallCheck(this, ExportLocalSpecifier);

  var name = arg.name,
      exportedName = arg.exportedName;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportLocalSpecifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {
    throw new TypeError('Argument to ExportLocalSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {
    throw new TypeError('Field "name" of ExportLocalSpecifier constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
  }
  if (typeof exportedName === 'undefined' || exportedName !== null && typeof exportedName !== 'string') {
    throw new TypeError('Field "exportedName" of ExportLocalSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
  }
  this.type = 'ExportLocalSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocals = exports.ExportLocals = function ExportLocals(arg) {
  _classCallCheck(this, ExportLocals);

  var namedExports = arg.namedExports;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExportLocals constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['namedExports'])) {
    throw new TypeError('Argument to ExportLocals constructor has wrong keys: expected {namedExports}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(namedExports) || namedExports.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'ExportLocalSpecifier';
  })) {
    throw new TypeError('Field "namedExports" of ExportLocals constructor argument is of incorrect type (expected [ExportLocalSpecifier], got ' + printActualType(namedExports) + ')');
  }
  this.type = 'ExportLocals';
  this.namedExports = namedExports;
};

var ExpressionStatement = exports.ExpressionStatement = function ExpressionStatement(arg) {
  _classCallCheck(this, ExpressionStatement);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ExpressionStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to ExpressionStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ExpressionStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ExpressionStatement';
  this.expression = expression;
};

var ForAwaitStatement = exports.ForAwaitStatement = function ForAwaitStatement(arg) {
  _classCallCheck(this, ForAwaitStatement);

  var left = arg.left,
      right = arg.right,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ForAwaitStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {
    throw new TypeError('Argument to ForAwaitStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {
    throw new TypeError('Field "left" of ForAwaitStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of ForAwaitStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForAwaitStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForAwaitStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForInStatement = exports.ForInStatement = function ForInStatement(arg) {
  _classCallCheck(this, ForInStatement);

  var left = arg.left,
      right = arg.right,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ForInStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {
    throw new TypeError('Argument to ForInStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {
    throw new TypeError('Field "left" of ForInStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of ForInStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForInStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForInStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForOfStatement = exports.ForOfStatement = function ForOfStatement(arg) {
  _classCallCheck(this, ForOfStatement);

  var left = arg.left,
      right = arg.right,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ForOfStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {
    throw new TypeError('Argument to ForOfStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {
    throw new TypeError('Field "left" of ForOfStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of ForOfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForOfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForOfStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForStatement = exports.ForStatement = function ForStatement(arg) {
  _classCallCheck(this, ForStatement);

  var init = arg.init,
      test = arg.test,
      update = arg.update,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ForStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'init', 'test', 'update'])) {
    throw new TypeError('Argument to ForStatement constructor has wrong keys: expected {init, test, update, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof init === 'undefined' || init !== null && isNotExpression(init) && init.type !== 'VariableDeclaration') {
    throw new TypeError('Field "init" of ForStatement constructor argument is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got ' + printActualType(init) + ')');
  }
  if (typeof test === 'undefined' || test !== null && isNotExpression(test)) {
    throw new TypeError('Field "test" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(test) + ')');
  }
  if (typeof update === 'undefined' || update !== null && isNotExpression(update)) {
    throw new TypeError('Field "update" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(update) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForStatement';
  this.init = init;
  this.test = test;
  this.update = update;
  this.body = body;
};

var FormalParameters = exports.FormalParameters = function FormalParameters(arg) {
  _classCallCheck(this, FormalParameters);

  var items = arg.items,
      rest = arg.rest;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('FormalParameters constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['items', 'rest'])) {
    throw new TypeError('Argument to FormalParameters constructor has wrong keys: expected {items, rest}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(items) || items.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding';
  })) {
    throw new TypeError('Field "items" of FormalParameters constructor argument is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(items) + ')');
  }
  if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {
    throw new TypeError('Field "rest" of FormalParameters constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
  }
  this.type = 'FormalParameters';
  this.items = items;
  this.rest = rest;
};

var FunctionBody = exports.FunctionBody = function FunctionBody(arg) {
  _classCallCheck(this, FunctionBody);

  var directives = arg.directives,
      statements = arg.statements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('FunctionBody constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {
    throw new TypeError('Argument to FunctionBody constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(directives) || directives.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of FunctionBody constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (!Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of FunctionBody constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'FunctionBody';
  this.directives = directives;
  this.statements = statements;
};

var FunctionDeclaration = exports.FunctionDeclaration = function FunctionDeclaration(arg) {
  _classCallCheck(this, FunctionDeclaration);

  var isAsync = arg.isAsync,
      isGenerator = arg.isGenerator,
      name = arg.name,
      params = arg.params,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('FunctionDeclaration constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {
    throw new TypeError('Argument to FunctionDeclaration constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isAsync !== 'boolean') {
    throw new TypeError('Field "isAsync" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');
  }
  if (typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of FunctionDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of FunctionDeclaration constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of FunctionDeclaration constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'FunctionDeclaration';
  this.isAsync = isAsync;
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var FunctionExpression = exports.FunctionExpression = function FunctionExpression(arg) {
  _classCallCheck(this, FunctionExpression);

  var isAsync = arg.isAsync,
      isGenerator = arg.isGenerator,
      name = arg.name,
      params = arg.params,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('FunctionExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {
    throw new TypeError('Argument to FunctionExpression constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isAsync !== 'boolean') {
    throw new TypeError('Field "isAsync" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');
  }
  if (typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (typeof name === 'undefined' || name !== null && name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of FunctionExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of FunctionExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of FunctionExpression constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'FunctionExpression';
  this.isAsync = isAsync;
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Getter = exports.Getter = function Getter(arg) {
  _classCallCheck(this, Getter);

  var name = arg.name,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Getter constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name'])) {
    throw new TypeError('Argument to Getter constructor has wrong keys: expected {name, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Getter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Getter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Getter';
  this.name = name;
  this.body = body;
};

var IdentifierExpression = exports.IdentifierExpression = function IdentifierExpression(arg) {
  _classCallCheck(this, IdentifierExpression);

  var name = arg.name;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('IdentifierExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {
    throw new TypeError('Argument to IdentifierExpression constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name !== 'string') {
    throw new TypeError('Field "name" of IdentifierExpression constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'IdentifierExpression';
  this.name = name;
};

var IfStatement = exports.IfStatement = function IfStatement(arg) {
  _classCallCheck(this, IfStatement);

  var test = arg.test,
      consequent = arg.consequent,
      alternate = arg.alternate;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('IfStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {
    throw new TypeError('Argument to IfStatement constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of IfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotStatement(consequent)) {
    throw new TypeError('Field "consequent" of IfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(consequent) + ')');
  }
  if (typeof alternate === 'undefined' || alternate !== null && isNotStatement(alternate)) {
    throw new TypeError('Field "alternate" of IfStatement constructor argument is of incorrect type (expected null or Statement, got ' + printActualType(alternate) + ')');
  }
  this.type = 'IfStatement';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var Import = exports.Import = function Import(arg) {
  _classCallCheck(this, Import);

  var defaultBinding = arg.defaultBinding,
      namedImports = arg.namedImports,
      moduleSpecifier = arg.moduleSpecifier;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Import constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namedImports'])) {
    throw new TypeError('Argument to Import constructor has wrong keys: expected {defaultBinding, namedImports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof defaultBinding === 'undefined' || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "defaultBinding" of Import constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
  }
  if (!Array.isArray(namedImports) || namedImports.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'ImportSpecifier';
  })) {
    throw new TypeError('Field "namedImports" of Import constructor argument is of incorrect type (expected [ImportSpecifier], got ' + printActualType(namedImports) + ')');
  }
  if (typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of Import constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'Import';
  this.defaultBinding = defaultBinding;
  this.namedImports = namedImports;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportNamespace = exports.ImportNamespace = function ImportNamespace(arg) {
  _classCallCheck(this, ImportNamespace);

  var defaultBinding = arg.defaultBinding,
      namespaceBinding = arg.namespaceBinding,
      moduleSpecifier = arg.moduleSpecifier;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ImportNamespace constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namespaceBinding'])) {
    throw new TypeError('Argument to ImportNamespace constructor has wrong keys: expected {defaultBinding, namespaceBinding, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof defaultBinding === 'undefined' || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "defaultBinding" of ImportNamespace constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
  }
  if (typeof namespaceBinding === 'undefined' || namespaceBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "namespaceBinding" of ImportNamespace constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(namespaceBinding) + ')');
  }
  if (typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ImportNamespace constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ImportNamespace';
  this.defaultBinding = defaultBinding;
  this.namespaceBinding = namespaceBinding;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportSpecifier = exports.ImportSpecifier = function ImportSpecifier(arg) {
  _classCallCheck(this, ImportSpecifier);

  var name = arg.name,
      binding = arg.binding;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ImportSpecifier constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {
    throw new TypeError('Argument to ImportSpecifier constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name !== null && typeof name !== 'string') {
    throw new TypeError('Field "name" of ImportSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(name) + ')');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "binding" of ImportSpecifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
  }
  this.type = 'ImportSpecifier';
  this.name = name;
  this.binding = binding;
};

var LabeledStatement = exports.LabeledStatement = function LabeledStatement(arg) {
  _classCallCheck(this, LabeledStatement);

  var label = arg.label,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('LabeledStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'label'])) {
    throw new TypeError('Argument to LabeledStatement constructor has wrong keys: expected {label, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof label !== 'string') {
    throw new TypeError('Field "label" of LabeledStatement constructor argument is of incorrect type (expected string, got ' + printActualType(label) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of LabeledStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'LabeledStatement';
  this.label = label;
  this.body = body;
};

var LiteralBooleanExpression = exports.LiteralBooleanExpression = function LiteralBooleanExpression(arg) {
  _classCallCheck(this, LiteralBooleanExpression);

  var value = arg.value;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('LiteralBooleanExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {
    throw new TypeError('Argument to LiteralBooleanExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof value !== 'boolean') {
    throw new TypeError('Field "value" of LiteralBooleanExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralBooleanExpression';
  this.value = value;
};

var LiteralInfinityExpression = exports.LiteralInfinityExpression = function LiteralInfinityExpression() {
  _classCallCheck(this, LiteralInfinityExpression);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('LiteralInfinityExpression constructor takes no arguments');
  }
  this.type = 'LiteralInfinityExpression';
};

var LiteralNullExpression = exports.LiteralNullExpression = function LiteralNullExpression() {
  _classCallCheck(this, LiteralNullExpression);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('LiteralNullExpression constructor takes no arguments');
  }
  this.type = 'LiteralNullExpression';
};

var LiteralNumericExpression = exports.LiteralNumericExpression = function LiteralNumericExpression(arg) {
  _classCallCheck(this, LiteralNumericExpression);

  var value = arg.value;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('LiteralNumericExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {
    throw new TypeError('Argument to LiteralNumericExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof value !== 'number') {
    throw new TypeError('Field "value" of LiteralNumericExpression constructor argument is of incorrect type (expected number, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralNumericExpression';
  this.value = value;
};

var LiteralRegExpExpression = exports.LiteralRegExpExpression = function LiteralRegExpExpression(arg) {
  _classCallCheck(this, LiteralRegExpExpression);

  var pattern = arg.pattern,
      global = arg.global,
      ignoreCase = arg.ignoreCase,
      multiLine = arg.multiLine,
      dotAll = arg.dotAll,
      unicode = arg.unicode,
      sticky = arg.sticky;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('LiteralRegExpExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['dotAll', 'global', 'ignoreCase', 'multiLine', 'pattern', 'sticky', 'unicode'])) {
    throw new TypeError('Argument to LiteralRegExpExpression constructor has wrong keys: expected {pattern, global, ignoreCase, multiLine, dotAll, unicode, sticky}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof pattern !== 'string') {
    throw new TypeError('Field "pattern" of LiteralRegExpExpression constructor argument is of incorrect type (expected string, got ' + printActualType(pattern) + ')');
  }
  if (typeof global !== 'boolean') {
    throw new TypeError('Field "global" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(global) + ')');
  }
  if (typeof ignoreCase !== 'boolean') {
    throw new TypeError('Field "ignoreCase" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(ignoreCase) + ')');
  }
  if (typeof multiLine !== 'boolean') {
    throw new TypeError('Field "multiLine" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(multiLine) + ')');
  }
  if (typeof dotAll !== 'boolean') {
    throw new TypeError('Field "dotAll" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(dotAll) + ')');
  }
  if (typeof unicode !== 'boolean') {
    throw new TypeError('Field "unicode" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(unicode) + ')');
  }
  if (typeof sticky !== 'boolean') {
    throw new TypeError('Field "sticky" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(sticky) + ')');
  }
  this.type = 'LiteralRegExpExpression';
  this.pattern = pattern;
  this.global = global;
  this.ignoreCase = ignoreCase;
  this.multiLine = multiLine;
  this.dotAll = dotAll;
  this.unicode = unicode;
  this.sticky = sticky;
};

var LiteralStringExpression = exports.LiteralStringExpression = function LiteralStringExpression(arg) {
  _classCallCheck(this, LiteralStringExpression);

  var value = arg.value;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('LiteralStringExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {
    throw new TypeError('Argument to LiteralStringExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof value !== 'string') {
    throw new TypeError('Field "value" of LiteralStringExpression constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralStringExpression';
  this.value = value;
};

var Method = exports.Method = function Method(arg) {
  _classCallCheck(this, Method);

  var isAsync = arg.isAsync,
      isGenerator = arg.isGenerator,
      name = arg.name,
      params = arg.params,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Method constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {
    throw new TypeError('Argument to Method constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isAsync !== 'boolean') {
    throw new TypeError('Field "isAsync" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');
  }
  if (typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Method constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of Method constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Method constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Method';
  this.isAsync = isAsync;
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Module = exports.Module = function Module(arg) {
  _classCallCheck(this, Module);

  var directives = arg.directives,
      items = arg.items;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Module constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'items'])) {
    throw new TypeError('Argument to Module constructor has wrong keys: expected {directives, items}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(directives) || directives.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of Module constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (!Array.isArray(items) || items.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'Export' && f.type !== 'ExportAllFrom' && f.type !== 'ExportDefault' && f.type !== 'ExportFrom' && f.type !== 'ExportLocals' && f.type !== 'Import' && f.type !== 'ImportNamespace' && isNotStatement(f);
  })) {
    throw new TypeError('Field "items" of Module constructor argument is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got ' + printActualType(items) + ')');
  }
  this.type = 'Module';
  this.directives = directives;
  this.items = items;
};

var NewExpression = exports.NewExpression = function NewExpression(arg) {
  _classCallCheck(this, NewExpression);

  var callee = arg.callee,
      _arguments = arg.arguments;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('NewExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {
    throw new TypeError('Argument to NewExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(callee)) {
    throw new TypeError('Field "callee" of NewExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(callee) + ')');
  }
  if (!Array.isArray(_arguments) || _arguments.some(function (f) {
    return typeof f === 'undefined' || isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "arguments" of NewExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
  }
  this.type = 'NewExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var NewTargetExpression = exports.NewTargetExpression = function NewTargetExpression() {
  _classCallCheck(this, NewTargetExpression);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('NewTargetExpression constructor takes no arguments');
  }
  this.type = 'NewTargetExpression';
};

var ObjectAssignmentTarget = exports.ObjectAssignmentTarget = function ObjectAssignmentTarget(arg) {
  _classCallCheck(this, ObjectAssignmentTarget);

  var properties = arg.properties,
      rest = arg.rest;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ObjectAssignmentTarget constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {
    throw new TypeError('Argument to ObjectAssignmentTarget constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(properties) || properties.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'AssignmentTargetPropertyIdentifier' && f.type !== 'AssignmentTargetPropertyProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectAssignmentTarget constructor argument is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got ' + printActualType(properties) + ')');
  }
  if (typeof rest === 'undefined' || rest !== null && rest.type !== 'ArrayAssignmentTarget' && rest.type !== 'ObjectAssignmentTarget' && rest.type !== 'AssignmentTargetIdentifier' && rest.type !== 'ComputedMemberAssignmentTarget' && rest.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "rest" of ObjectAssignmentTarget constructor argument is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ObjectAssignmentTarget';
  this.properties = properties;
  this.rest = rest;
};

var ObjectBinding = exports.ObjectBinding = function ObjectBinding(arg) {
  _classCallCheck(this, ObjectBinding);

  var properties = arg.properties,
      rest = arg.rest;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ObjectBinding constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {
    throw new TypeError('Argument to ObjectBinding constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(properties) || properties.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'BindingPropertyIdentifier' && f.type !== 'BindingPropertyProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectBinding constructor argument is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got ' + printActualType(properties) + ')');
  }
  if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {
    throw new TypeError('Field "rest" of ObjectBinding constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ObjectBinding';
  this.properties = properties;
  this.rest = rest;
};

var ObjectExpression = exports.ObjectExpression = function ObjectExpression(arg) {
  _classCallCheck(this, ObjectExpression);

  var properties = arg.properties;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ObjectExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['properties'])) {
    throw new TypeError('Argument to ObjectExpression constructor has wrong keys: expected {properties}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(properties) || properties.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'DataProperty' && f.type !== 'Getter' && f.type !== 'Method' && f.type !== 'Setter' && f.type !== 'ShorthandProperty' && f.type !== 'SpreadProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectExpression constructor argument is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty, SpreadProperty}], got ' + printActualType(properties) + ')');
  }
  this.type = 'ObjectExpression';
  this.properties = properties;
};

var ReturnStatement = exports.ReturnStatement = function ReturnStatement(arg) {
  _classCallCheck(this, ReturnStatement);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ReturnStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to ReturnStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof expression === 'undefined' || expression !== null && isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ReturnStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ReturnStatement';
  this.expression = expression;
};

var Script = exports.Script = function Script(arg) {
  _classCallCheck(this, Script);

  var directives = arg.directives,
      statements = arg.statements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Script constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {
    throw new TypeError('Argument to Script constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(directives) || directives.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of Script constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (!Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of Script constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'Script';
  this.directives = directives;
  this.statements = statements;
};

var Setter = exports.Setter = function Setter(arg) {
  _classCallCheck(this, Setter);

  var name = arg.name,
      param = arg.param,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('Setter constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name', 'param'])) {
    throw new TypeError('Argument to Setter constructor has wrong keys: expected {name, param, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Setter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (typeof param === 'undefined' || param.type !== 'BindingWithDefault' && param.type !== 'BindingIdentifier' && param.type !== 'ArrayBinding' && param.type !== 'ObjectBinding') {
    throw new TypeError('Field "param" of Setter constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(param) + ')');
  }
  if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Setter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Setter';
  this.name = name;
  this.param = param;
  this.body = body;
};

var ShorthandProperty = exports.ShorthandProperty = function ShorthandProperty(arg) {
  _classCallCheck(this, ShorthandProperty);

  var name = arg.name;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ShorthandProperty constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {
    throw new TypeError('Argument to ShorthandProperty constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {
    throw new TypeError('Field "name" of ShorthandProperty constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
  }
  this.type = 'ShorthandProperty';
  this.name = name;
};

var SpreadElement = exports.SpreadElement = function SpreadElement(arg) {
  _classCallCheck(this, SpreadElement);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SpreadElement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to SpreadElement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of SpreadElement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'SpreadElement';
  this.expression = expression;
};

var SpreadProperty = exports.SpreadProperty = function SpreadProperty(arg) {
  _classCallCheck(this, SpreadProperty);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SpreadProperty constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to SpreadProperty constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of SpreadProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'SpreadProperty';
  this.expression = expression;
};

var StaticMemberAssignmentTarget = exports.StaticMemberAssignmentTarget = function StaticMemberAssignmentTarget(arg) {
  _classCallCheck(this, StaticMemberAssignmentTarget);

  var object = arg.object,
      property = arg.property;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('StaticMemberAssignmentTarget constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {
    throw new TypeError('Argument to StaticMemberAssignmentTarget constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (typeof property !== 'string') {
    throw new TypeError('Field "property" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');
  }
  this.type = 'StaticMemberAssignmentTarget';
  this.object = object;
  this.property = property;
};

var StaticMemberExpression = exports.StaticMemberExpression = function StaticMemberExpression(arg) {
  _classCallCheck(this, StaticMemberExpression);

  var object = arg.object,
      property = arg.property;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('StaticMemberExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {
    throw new TypeError('Argument to StaticMemberExpression constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of StaticMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (typeof property !== 'string') {
    throw new TypeError('Field "property" of StaticMemberExpression constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');
  }
  this.type = 'StaticMemberExpression';
  this.object = object;
  this.property = property;
};

var StaticPropertyName = exports.StaticPropertyName = function StaticPropertyName(arg) {
  _classCallCheck(this, StaticPropertyName);

  var value = arg.value;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('StaticPropertyName constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {
    throw new TypeError('Argument to StaticPropertyName constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof value !== 'string') {
    throw new TypeError('Field "value" of StaticPropertyName constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');
  }
  this.type = 'StaticPropertyName';
  this.value = value;
};

var Super = exports.Super = function Super() {
  _classCallCheck(this, Super);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('Super constructor takes no arguments');
  }
  this.type = 'Super';
};

var SwitchCase = exports.SwitchCase = function SwitchCase(arg) {
  _classCallCheck(this, SwitchCase);

  var test = arg.test,
      consequent = arg.consequent;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SwitchCase constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['consequent', 'test'])) {
    throw new TypeError('Argument to SwitchCase constructor has wrong keys: expected {test, consequent}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of SwitchCase constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (!Array.isArray(consequent) || consequent.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "consequent" of SwitchCase constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
  }
  this.type = 'SwitchCase';
  this.test = test;
  this.consequent = consequent;
};

var SwitchDefault = exports.SwitchDefault = function SwitchDefault(arg) {
  _classCallCheck(this, SwitchDefault);

  var consequent = arg.consequent;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SwitchDefault constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['consequent'])) {
    throw new TypeError('Argument to SwitchDefault constructor has wrong keys: expected {consequent}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (!Array.isArray(consequent) || consequent.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "consequent" of SwitchDefault constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
  }
  this.type = 'SwitchDefault';
  this.consequent = consequent;
};

var SwitchStatement = exports.SwitchStatement = function SwitchStatement(arg) {
  _classCallCheck(this, SwitchStatement);

  var discriminant = arg.discriminant,
      cases = arg.cases;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SwitchStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['cases', 'discriminant'])) {
    throw new TypeError('Argument to SwitchStatement constructor has wrong keys: expected {discriminant, cases}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(discriminant)) {
    throw new TypeError('Field "discriminant" of SwitchStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
  }
  if (!Array.isArray(cases) || cases.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "cases" of SwitchStatement constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(cases) + ')');
  }
  this.type = 'SwitchStatement';
  this.discriminant = discriminant;
  this.cases = cases;
};

var SwitchStatementWithDefault = exports.SwitchStatementWithDefault = function SwitchStatementWithDefault(arg) {
  _classCallCheck(this, SwitchStatementWithDefault);

  var discriminant = arg.discriminant,
      preDefaultCases = arg.preDefaultCases,
      defaultCase = arg.defaultCase,
      postDefaultCases = arg.postDefaultCases;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('SwitchStatementWithDefault constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['defaultCase', 'discriminant', 'postDefaultCases', 'preDefaultCases'])) {
    throw new TypeError('Argument to SwitchStatementWithDefault constructor has wrong keys: expected {discriminant, preDefaultCases, defaultCase, postDefaultCases}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(discriminant)) {
    throw new TypeError('Field "discriminant" of SwitchStatementWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
  }
  if (!Array.isArray(preDefaultCases) || preDefaultCases.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "preDefaultCases" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(preDefaultCases) + ')');
  }
  if (typeof defaultCase === 'undefined' || defaultCase.type !== 'SwitchDefault') {
    throw new TypeError('Field "defaultCase" of SwitchStatementWithDefault constructor argument is of incorrect type (expected SwitchDefault, got ' + printActualType(defaultCase) + ')');
  }
  if (!Array.isArray(postDefaultCases) || postDefaultCases.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "postDefaultCases" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(postDefaultCases) + ')');
  }
  this.type = 'SwitchStatementWithDefault';
  this.discriminant = discriminant;
  this.preDefaultCases = preDefaultCases;
  this.defaultCase = defaultCase;
  this.postDefaultCases = postDefaultCases;
};

var TemplateElement = exports.TemplateElement = function TemplateElement(arg) {
  _classCallCheck(this, TemplateElement);

  var rawValue = arg.rawValue;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('TemplateElement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {
    throw new TypeError('Argument to TemplateElement constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof rawValue !== 'string') {
    throw new TypeError('Field "rawValue" of TemplateElement constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
  }
  this.type = 'TemplateElement';
  this.rawValue = rawValue;
};

var TemplateExpression = exports.TemplateExpression = function TemplateExpression(arg) {
  _classCallCheck(this, TemplateExpression);

  var tag = arg.tag,
      elements = arg.elements;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('TemplateExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'tag'])) {
    throw new TypeError('Argument to TemplateExpression constructor has wrong keys: expected {tag, elements}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof tag === 'undefined' || tag !== null && isNotExpression(tag)) {
    throw new TypeError('Field "tag" of TemplateExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(tag) + ')');
  }
  if (!Array.isArray(elements) || elements.some(function (f) {
    return typeof f === 'undefined' || isNotExpression(f) && f.type !== 'TemplateElement';
  })) {
    throw new TypeError('Field "elements" of TemplateExpression constructor argument is of incorrect type (expected [one of {Expression, TemplateElement}], got ' + printActualType(elements) + ')');
  }
  this.type = 'TemplateExpression';
  this.tag = tag;
  this.elements = elements;
};

var ThisExpression = exports.ThisExpression = function ThisExpression() {
  _classCallCheck(this, ThisExpression);

  if (arguments.length > 1 || arguments.length === 1 && (_typeof(arguments.length <= 0 ? undefined : arguments[0]) !== 'object' || (arguments.length <= 0 ? undefined : arguments[0]) === null || Object.keys(arguments.length <= 0 ? undefined : arguments[0]).length !== 0)) {
    throw new TypeError('ThisExpression constructor takes no arguments');
  }
  this.type = 'ThisExpression';
};

var ThrowStatement = exports.ThrowStatement = function ThrowStatement(arg) {
  _classCallCheck(this, ThrowStatement);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('ThrowStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to ThrowStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ThrowStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ThrowStatement';
  this.expression = expression;
};

var TryCatchStatement = exports.TryCatchStatement = function TryCatchStatement(arg) {
  _classCallCheck(this, TryCatchStatement);

  var body = arg.body,
      catchClause = arg.catchClause;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('TryCatchStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause'])) {
    throw new TypeError('Argument to TryCatchStatement constructor has wrong keys: expected {body, catchClause}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof body === 'undefined' || body.type !== 'Block') {
    throw new TypeError('Field "body" of TryCatchStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  if (typeof catchClause === 'undefined' || catchClause.type !== 'CatchClause') {
    throw new TypeError('Field "catchClause" of TryCatchStatement constructor argument is of incorrect type (expected CatchClause, got ' + printActualType(catchClause) + ')');
  }
  this.type = 'TryCatchStatement';
  this.body = body;
  this.catchClause = catchClause;
};

var TryFinallyStatement = exports.TryFinallyStatement = function TryFinallyStatement(arg) {
  _classCallCheck(this, TryFinallyStatement);

  var body = arg.body,
      catchClause = arg.catchClause,
      finalizer = arg.finalizer;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('TryFinallyStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause', 'finalizer'])) {
    throw new TypeError('Argument to TryFinallyStatement constructor has wrong keys: expected {body, catchClause, finalizer}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof body === 'undefined' || body.type !== 'Block') {
    throw new TypeError('Field "body" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  if (typeof catchClause === 'undefined' || catchClause !== null && catchClause.type !== 'CatchClause') {
    throw new TypeError('Field "catchClause" of TryFinallyStatement constructor argument is of incorrect type (expected null or CatchClause, got ' + printActualType(catchClause) + ')');
  }
  if (typeof finalizer === 'undefined' || finalizer.type !== 'Block') {
    throw new TypeError('Field "finalizer" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(finalizer) + ')');
  }
  this.type = 'TryFinallyStatement';
  this.body = body;
  this.catchClause = catchClause;
  this.finalizer = finalizer;
};

var UnaryExpression = exports.UnaryExpression = function UnaryExpression(arg) {
  _classCallCheck(this, UnaryExpression);

  var operator = arg.operator,
      operand = arg.operand;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('UnaryExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['operand', 'operator'])) {
    throw new TypeError('Argument to UnaryExpression constructor has wrong keys: expected {operator, operand}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof operator === 'undefined' || ['+', '-', '!', '~', 'typeof', 'void', 'delete'].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of UnaryExpression constructor argument is of incorrect type (expected one of {"+", "-", "!", "~", "typeof", "void", "delete"}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(operand)) {
    throw new TypeError('Field "operand" of UnaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(operand) + ')');
  }
  this.type = 'UnaryExpression';
  this.operator = operator;
  this.operand = operand;
};

var UpdateExpression = exports.UpdateExpression = function UpdateExpression(arg) {
  _classCallCheck(this, UpdateExpression);

  var isPrefix = arg.isPrefix,
      operator = arg.operator,
      operand = arg.operand;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('UpdateExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['isPrefix', 'operand', 'operator'])) {
    throw new TypeError('Argument to UpdateExpression constructor has wrong keys: expected {isPrefix, operator, operand}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof isPrefix !== 'boolean') {
    throw new TypeError('Field "isPrefix" of UpdateExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isPrefix) + ')');
  }
  if (typeof operator === 'undefined' || ['++', '--'].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of UpdateExpression constructor argument is of incorrect type (expected one of {"++", "--"}, got ' + printActualType(operator) + ')');
  }
  if (typeof operand === 'undefined' || operand.type !== 'AssignmentTargetIdentifier' && operand.type !== 'ComputedMemberAssignmentTarget' && operand.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "operand" of UpdateExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(operand) + ')');
  }
  this.type = 'UpdateExpression';
  this.isPrefix = isPrefix;
  this.operator = operator;
  this.operand = operand;
};

var VariableDeclaration = exports.VariableDeclaration = function VariableDeclaration(arg) {
  _classCallCheck(this, VariableDeclaration);

  var kind = arg.kind,
      declarators = arg.declarators;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('VariableDeclaration constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['declarators', 'kind'])) {
    throw new TypeError('Argument to VariableDeclaration constructor has wrong keys: expected {kind, declarators}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof kind === 'undefined' || ['var', 'let', 'const'].indexOf(kind) === -1) {
    throw new TypeError('Field "kind" of VariableDeclaration constructor argument is of incorrect type (expected one of {"var", "let", "const"}, got ' + printActualType(kind) + ')');
  }
  if (!Array.isArray(declarators) || declarators.some(function (f) {
    return typeof f === 'undefined' || f.type !== 'VariableDeclarator';
  })) {
    throw new TypeError('Field "declarators" of VariableDeclaration constructor argument is of incorrect type (expected [VariableDeclarator], got ' + printActualType(declarators) + ')');
  }
  this.type = 'VariableDeclaration';
  this.kind = kind;
  this.declarators = declarators;
};

var VariableDeclarationStatement = exports.VariableDeclarationStatement = function VariableDeclarationStatement(arg) {
  _classCallCheck(this, VariableDeclarationStatement);

  var declaration = arg.declaration;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('VariableDeclarationStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {
    throw new TypeError('Argument to VariableDeclarationStatement constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof declaration === 'undefined' || declaration.type !== 'VariableDeclaration') {
    throw new TypeError('Field "declaration" of VariableDeclarationStatement constructor argument is of incorrect type (expected VariableDeclaration, got ' + printActualType(declaration) + ')');
  }
  this.type = 'VariableDeclarationStatement';
  this.declaration = declaration;
};

var VariableDeclarator = exports.VariableDeclarator = function VariableDeclarator(arg) {
  _classCallCheck(this, VariableDeclarator);

  var binding = arg.binding,
      init = arg.init;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('VariableDeclarator constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {
    throw new TypeError('Argument to VariableDeclarator constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of VariableDeclarator constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of VariableDeclarator constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'VariableDeclarator';
  this.binding = binding;
  this.init = init;
};

var WhileStatement = exports.WhileStatement = function WhileStatement(arg) {
  _classCallCheck(this, WhileStatement);

  var test = arg.test,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('WhileStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {
    throw new TypeError('Argument to WhileStatement constructor has wrong keys: expected {test, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of WhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of WhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'WhileStatement';
  this.test = test;
  this.body = body;
};

var WithStatement = exports.WithStatement = function WithStatement(arg) {
  _classCallCheck(this, WithStatement);

  var object = arg.object,
      body = arg.body;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('WithStatement constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['body', 'object'])) {
    throw new TypeError('Argument to WithStatement constructor has wrong keys: expected {object, body}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(object)) {
    throw new TypeError('Field "object" of WithStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(object) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of WithStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'WithStatement';
  this.object = object;
  this.body = body;
};

var YieldExpression = exports.YieldExpression = function YieldExpression(arg) {
  _classCallCheck(this, YieldExpression);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('YieldExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to YieldExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (typeof expression === 'undefined' || expression !== null && isNotExpression(expression)) {
    throw new TypeError('Field "expression" of YieldExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'YieldExpression';
  this.expression = expression;
};

var YieldGeneratorExpression = exports.YieldGeneratorExpression = function YieldGeneratorExpression(arg) {
  _classCallCheck(this, YieldGeneratorExpression);

  var expression = arg.expression;

  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new TypeError('YieldGeneratorExpression constructor takes exactly one argument (' + (1 + (arguments.length <= 1 ? 0 : arguments.length - 1)) + ' given)');
  }
  if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {
    throw new TypeError('Argument to YieldGeneratorExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of YieldGeneratorExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'YieldGeneratorExpression';
  this.expression = expression;
};