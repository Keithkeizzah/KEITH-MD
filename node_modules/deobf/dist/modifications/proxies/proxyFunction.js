"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const shift_parser_1 = __importDefault(require("shift-parser"));
const shift_codegen_1 = __importDefault(require("shift-codegen"));
const traverse_1 = require("../../helpers/traverse");
const traversalHelper_1 = __importDefault(require("../../helpers/traversalHelper"));
class ProxyFunction {
    /**
     * Creates a new proxy function.
     * @param node The function node.
     * @param parentNode The parent node.
     * @param name The name of the proxy function.
     * @param params The parameters of the proxy function.
     * @param expression The expression returned by the proxy function.
     */
    constructor(node, parentNode, name, params, expression) {
        this.node = node;
        this.parentNode = parentNode;
        this.name = name;
        this.params = params;
        this.expression = expression;
    }
    /**
     * Returns the replacement for a call of the proxy function.
     * @param args The arguments of the proxy function call.
     */
    getReplacement(args) {
        let expression = this.duplicateExpression(this.expression);
        const paramUsages = this.findParameterUsages(expression);
        for (const [index, usages] of paramUsages) {
            const arg = args[index];
            if (arg) {
                for (const usage of usages) {
                    if (!usage.parentNode) {
                        expression = arg;
                    }
                    else {
                        traversalHelper_1.default.replaceNode(usage.parentNode, usage.node, arg);
                    }
                }
            }
        }
        return expression;
    }
    /**
     * Finds all usages of the proxy function's parameters within a given
     * expression.
     * @param expression The expression node.
     */
    findParameterUsages(expression) {
        const params = this.params.map((p) => p.name);
        const paramUsages = new Map();
        traverse_1.traverse(expression, {
            enter(node, parent) {
                if (node.type == "IdentifierExpression" ||
                    node.type == "AssignmentTargetIdentifier") {
                    const name = node.name;
                    const index = params.indexOf(name);
                    if (index != -1) {
                        const usage = new ParamUsage(node, parent);
                        let usages;
                        if (paramUsages.has(index)) {
                            usages = paramUsages.get(index);
                        }
                        else {
                            usages = [];
                            paramUsages.set(index, usages);
                        }
                        usages.push(usage);
                    }
                }
            },
        });
        return paramUsages;
    }
    /**
     * Returns a copy of an expression.
     * @param node The expression node.
     */
    duplicateExpression(expression) {
        const code = shift_codegen_1.default(expression);
        const ast = shift_parser_1.default(code);
        return ast.statements[0].expression;
    }
}
exports.default = ProxyFunction;
class ParamUsage {
    constructor(node, parentNode) {
        this.node = node;
        this.parentNode = parentNode;
    }
}
