"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vm2_1 = require("vm2");
const modification_1 = __importDefault(require("../../modification"));
const Shift = __importStar(require("shift-ast"));
const traverse_1 = require("../../helpers/traverse");
const traversalHelper_1 = __importDefault(require("../../helpers/traversalHelper"));
const vm = new vm2_1.VM({
    timeout: 1000,
    sandbox: {},
});
class ExpressionSimplifier extends modification_1.default {
    /**
     * Creates a new modification.
     * @param ast The AST.
     */
    constructor(ast) {
        super("Simplify Expressions", ast);
        this.types = new Set(["BinaryExpression", "UnaryExpression"]);
    }
    /**
     * Executes the modification.
     */
    execute() {
        this.simplifyExpressions();
    }
    /**
     * Simplifies all binary and unary expressions.
     */
    simplifyExpressions() {
        const self = this;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.types.has(node.type)) {
                    const replacement = self.simplifyExpression(node);
                    if (replacement != node) {
                        traversalHelper_1.default.replaceNode(parent, node, replacement);
                    }
                }
            },
        });
    }
    /**
     * Attempts to simplify an expression node.
     * @param expression The expression node.
     */
    simplifyExpression(expression) {
        switch (expression.type) {
            case "BinaryExpression":
                return this.simplifyBinaryExpression(expression);
            case "UnaryExpression":
                return this.simplifyUnaryExpression(expression);
            default:
                return expression;
        }
    }
    /**
     * Attempts to simplify a binary expression node.
     * @param expression The binary expression node.
     */
    simplifyBinaryExpression(expression) {
        const left = this.simplifyExpression(expression.left);
        const right = this.simplifyExpression(expression.right);
        const leftValue = this.getExpressionValueAsString(left);
        const rightValue = this.getExpressionValueAsString(right);
        if (leftValue != null && rightValue != null) {
            const code = `${leftValue} ${expression.operator} ${rightValue}`;
            const simplified = this.evalCodeToExpression(code);
            return simplified != null ? simplified : expression;
        }
        else {
            return expression;
        }
    }
    /**
     * Attempts to simplify a unary expression node.
     * @param expression The unary expression node.
     */
    simplifyUnaryExpression(expression) {
        expression.operand = this.simplifyExpression(expression.operand);
        const code = this.getExpressionValueAsString(expression);
        if (code != null) {
            const simplified = this.evalCodeToExpression(code);
            return simplified != null ? simplified : expression;
        }
        else {
            return expression;
        }
    }
    /**
     * Returns the value of a node as a string, null if not possible.
     * @param expression The expression node.
     */
    getExpressionValueAsString(expression) {
        switch (expression.type) {
            case "LiteralStringExpression":
                return `"${expression.value.replace(/"/g, '\\"')}"`;
            case "LiteralNumericExpression":
                return expression.value.toString();
            case "UnaryExpression":
                const operand = this.getExpressionValueAsString(expression.operand);
                return operand != null ? expression.operator + operand : null;
            default:
                return null;
        }
    }
    /**
     * Evaluates a given piece of code and converts the result to an
     * expression node if possible.
     * @param code The code to be evaluated.
     */
    evalCodeToExpression(code) {
        let value;
        try {
            value = vm.run(code);
        }
        catch {
            return null;
        }
        switch (typeof value) {
            case "string":
                return new Shift.LiteralStringExpression({
                    value: value,
                });
            case "number":
                return new Shift.LiteralNumericExpression({
                    value: value,
                });
            case "boolean":
                return new Shift.LiteralBooleanExpression({
                    value: value,
                });
            default:
                return null;
        }
    }
}
exports.default = ExpressionSimplifier;
