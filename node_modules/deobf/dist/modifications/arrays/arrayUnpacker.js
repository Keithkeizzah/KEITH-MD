"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const modification_1 = __importDefault(require("../../modification"));
const traverse_1 = require("../../helpers/traverse");
const array_1 = __importDefault(require("./array"));
const scope_1 = __importDefault(require("./scope"));
const traversalHelper_1 = __importDefault(require("../../helpers/traversalHelper"));
class ArrayUnpacker extends modification_1.default {
    /**
     * Creates a new modification.
     * @param ast The AST.
     * @param shouldRemoveArrays Whether the arrays should be removed.
     */
    constructor(ast, removeArrays) {
        super("Unpack Arrays", ast);
        this.scopeTypes = new Set(["Block", "FunctionBody"]);
        this.shouldRemoveArrays = removeArrays;
        this.globalScope = new scope_1.default(this.ast);
    }
    /**
     * Executes the modification.
     */
    execute() {
        this.findArrays();
        this.unpackArrays();
        if (this.shouldRemoveArrays) {
            this.removeArrays(this.globalScope);
        }
    }
    /**
     * Finds all literal arrays and stores them in the according scope.
     */
    findArrays() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.scopeTypes.has(node.type)) {
                    scope = new scope_1.default(node, scope);
                }
                else if (self.isLiteralArrayDeclaration(node)) {
                    const name = node.binding.name;
                    const elements = node.init.elements;
                    const array = new array_1.default(node, parent, name, elements);
                    scope.addArray(array);
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            },
        });
    }
    /**
     * Replaces all usages of literal arrays.
     */
    unpackArrays() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.scopeTypes.has(node.type)) {
                    scope = scope.children.get(node);
                }
                else if (self.isSimpleArrayAccess(node)) {
                    const name = node.object.name;
                    const array = scope.findArray(name);
                    if (array) {
                        const index = node.expression.value;
                        const replacement = array.elements[index];
                        if (replacement) {
                            array.replaceCount++;
                            traversalHelper_1.default.replaceNode(parent, node, replacement);
                        }
                    }
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            },
        });
    }
    /**
     * Removes all the (suitable) arrays in a scope and its children.
     * @param scope The scope to remove arrays from.
     */
    removeArrays(scope) {
        for (const [_, array] of scope.arrays) {
            if (array.replaceCount > 0) {
                traversalHelper_1.default.removeNode(array.parentNode, array.node);
            }
        }
        for (const [_, child] of scope.children) {
            this.removeArrays(child);
        }
    }
    /**
     * Returns whether a node is a literal array declaration.
     * @param node The AST node.
     */
    isLiteralArrayDeclaration(node) {
        return (node.type == "VariableDeclarator" &&
            node.binding.type == "BindingIdentifier" &&
            node.init != null &&
            node.init.type == "ArrayExpression" &&
            node.init.elements.find((e) => e && !e.type.startsWith("Literal")) ==
                undefined);
    }
    /**
     * Returns whether a node is accessing an index of an array.
     * @param node The AST node.
     */
    isSimpleArrayAccess(node) {
        return (node.type == "ComputedMemberExpression" &&
            node.object.type == "IdentifierExpression" &&
            node.expression.type == "LiteralNumericExpression");
    }
}
exports.default = ArrayUnpacker;
