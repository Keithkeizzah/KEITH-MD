"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeType = exports.Scope = void 0;
class Scope {
    /**
     * Creates a new scope.
     * @param node The AST node that created the scope.
     * @param type The scope type.
     * @param parent The parent scope (if it exists).
     */
    constructor(node, type, parent) {
        this.node = node;
        this.type = type;
        this.parent = parent;
        this.children = [];
        this.variables = new Map();
        if (this.parent) {
            this.parent.children.push(this);
        }
    }
    /**
     * Searches for a variable by name.
     * @param name The variable name.
     * @returns The variable or null if not found.
     */
    lookupVariable(name) {
        if (this.variables.has(name)) {
            return this.variables.get(name);
        }
        return this.parent ? this.parent.lookupVariable(name) : null;
    }
    /**
     * Adds a variable to the scope (or a parent scope).
     * @param variable The variable.
     */
    addVariable(variable) {
        switch (variable.type) {
            case "const":
            case "let": {
                this.variables.set(variable.name, variable);
                break;
            }
            case "var": {
                const scope = this.findScope([ScopeType.Function, ScopeType.Global]);
                if (!scope) {
                    throw new Error("Failed to find scope for variable declaration");
                }
                scope.variables.set(variable.name, variable);
                break;
            }
            case undefined: {
                const scope = this.findScope([ScopeType.Global]);
                if (!scope) {
                    throw new Error("Failed to find scope for variable declaration");
                }
                scope.variables.set(variable.name, variable);
                break;
            }
        }
    }
    /**
     * Gets the scope for a declaration.
     * @param type The declaration type.
     * @returns The scope.
     */
    getDeclarationScope(type) {
        switch (type) {
            case "const":
            case "let":
                return this;
            case "var": {
                const scope = this.findScope([ScopeType.Function, ScopeType.Global]);
                if (!scope) {
                    throw new Error("Failed to find scope for variable declaration");
                }
                return scope;
            }
        }
    }
    /**
     * Finds a scope with a given type.
     * @param types The desired scope types.
     * @returns The scope found or undefined.
     */
    findScope(types) {
        let scope = this;
        while (scope && !types.includes(scope.type)) {
            scope = scope.parent;
        }
        return scope;
    }
}
exports.Scope = Scope;
var ScopeType;
(function (ScopeType) {
    ScopeType["Global"] = "Global";
    ScopeType["Function"] = "Function";
    ScopeType["Other"] = "Other";
})(ScopeType = exports.ScopeType || (exports.ScopeType = {}));
