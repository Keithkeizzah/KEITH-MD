"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const modification_1 = __importDefault(require("../../modification"));
const scope_1 = require("./scope");
const traverse_1 = require("../../helpers/traverse");
const variable_1 = require("./variable");
const names_json_1 = __importDefault(require("./names.json"));
class VariableRenamer extends modification_1.default {
    /**
     * Creates a new modification.
     * @param ast The AST.
     */
    constructor(ast) {
        super("Rename Variables", ast);
        this.ALPHABET = "abcdefghijklmnopqrstuvwxyz";
        this.globalScope = new scope_1.Scope(this.ast, scope_1.ScopeType.Global);
        this.variableNames = [];
        this.usedVariableNames = new Set([
            "if",
            "do",
            "in",
            "var",
            "let",
            "try",
            "for",
        ]);
    }
    /**
     * Executes the modification.
     */
    execute() {
        this.collectDeclarations();
        this.collectReferences();
        this.generateNames();
        this.renameVariables(this.globalScope);
    }
    /**
     * Finds all variable declarations.
     */
    collectDeclarations() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node) {
                switch (node.type) {
                    case "FunctionDeclaration": {
                        const variable = new variable_1.Variable(node.name.name, "var");
                        variable.declarations.push(node.name);
                        scope.addVariable(variable);
                        self.addName(node.name.name);
                    }
                    case "FunctionExpression":
                    case "ArrowExpression": {
                        scope = new scope_1.Scope(node, scope_1.ScopeType.Function, scope);
                        // name of function expressions is added to inner function scope
                        if (node.type == "FunctionExpression" && node.name) {
                            const variable = new variable_1.Variable(node.name.name, "var");
                            variable.declarations.push(node.name);
                            scope.addVariable(variable);
                            self.addName(node.name.name);
                        }
                        // add function params to scope
                        for (const param of node.params.items) {
                            if (param.type == "BindingIdentifier") {
                                const variable = new variable_1.Variable(param.name, "var");
                                variable.declarations.push(param);
                                scope.addVariable(variable);
                                self.addName(param.name);
                            }
                        }
                        // add 'arguments' to scope
                        if (node.type != "ArrowExpression") {
                            const variable = new variable_1.Variable("arguments", "var");
                            scope.addVariable(variable);
                        }
                        break;
                    }
                    case "CatchClause": {
                        if (node.binding && node.binding.type == "BindingIdentifier") {
                            const variable = new variable_1.Variable(node.binding.name, "let");
                            variable.declarations.push(node.binding);
                            scope.addVariable(variable);
                            self.addName(node.binding.name);
                        }
                    }
                    case "ForStatement":
                    case "BlockStatement": {
                        scope = new scope_1.Scope(node, scope_1.ScopeType.Other, scope);
                        break;
                    }
                    case "VariableDeclaration": {
                        for (const declarator of node.declarators) {
                            if (declarator.binding.type != "BindingIdentifier") {
                                break;
                            }
                            let variable;
                            const declarationScope = scope.getDeclarationScope(node.kind);
                            if (declarationScope.variables.has(declarator.binding.name)) {
                                variable = declarationScope.variables.get(declarator.binding.name);
                                if (variable.isBlockScoped() ||
                                    variable_1.blockScopedTypes.has(node.kind)) {
                                    throw new Error(`Identifier ${variable.name} has already been declared`);
                                }
                            }
                            else {
                                variable = new variable_1.Variable(declarator.binding.name, node.kind);
                                scope.addVariable(variable);
                                self.addName(declarator.binding.name);
                            }
                            variable.declarations.push(declarator.binding);
                        }
                        break;
                    }
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            },
        });
    }
    /**
     * Finds all references of variables.
     */
    collectReferences() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node) {
                switch (node.type) {
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ArrowExpression":
                    case "CatchClause":
                    case "ForStatement":
                    case "BlockStatement": {
                        const newScope = scope.children.find((s) => s.node == node);
                        if (!newScope) {
                            throw new Error(`Failed to find scope of type ${node.type}`);
                        }
                        scope = newScope;
                        break;
                    }
                    case "IdentifierExpression":
                    case "AssignmentTargetIdentifier": {
                        let variable = scope.lookupVariable(node.name);
                        // handle global variables
                        if (!variable) {
                            variable = new variable_1.Variable(node.name, "var");
                            self.addName(node.name);
                        }
                        variable.references.push(node);
                        break;
                    }
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            },
        });
    }
    /**
     * Renames all suitable variables within a given scope and it's
     * children.
     * @param scope The scope.
     */
    renameVariables(scope) {
        for (const [name, variable] of scope.variables) {
            if (this.shouldRename(name)) {
                const newName = this.getVariableName();
                variable.rename(newName);
            }
        }
        for (const childScope of scope.children) {
            this.renameVariables(childScope);
        }
    }
    /**
     * Generates a list of unique variable names.
     */
    generateNames() {
        const variableNames = this.shuffleArray(names_json_1.default).reduce((arr, name) => {
            if (!this.usedVariableNames.has(name)) {
                arr.push(name);
            }
            return arr;
        }, []);
        this.variableNames = variableNames;
    }
    /**
     * Randomly shuffles an array.
     * @param array The array to be shuffled.
     * @returns The shuffled array.
     */
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    }
    /**
     * Returns the next unique variable name.
     * @returns The next variable name.
     */
    getVariableName() {
        if (this.variableNames.length == 0) {
            throw new Error(`Ran out of variable names`);
        }
        return this.variableNames.shift();
    }
    /**
     * Records a variable name as used.
     * @param name The variable name.
     */
    addName(name) {
        if (!this.shouldRename(name)) {
            this.usedVariableNames.add(name);
        }
    }
    /**
     * Returns whether a variable name should be renamed.
     * @param name The variable name.
     * @returns Whether.
     */
    shouldRename(name) {
        return name.startsWith("_0x");
    }
}
exports.default = VariableRenamer;
